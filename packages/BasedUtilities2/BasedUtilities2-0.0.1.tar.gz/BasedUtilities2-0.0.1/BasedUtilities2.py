"""COPYRIGHT 2021 """
""" ABOUT US:
MUSIC PLAYLIST LINK HERE:
WE CURRENTLY HOLD AT LEAST ONE EMPLOYEE IN OUR COMPANY HEADQUARTERS APPLY TO JOIN OUR BIG TECH COMPANY: 
LAW ENFORCEMENT HAS BEEN BAN.
"""
"""" TERMS OF SERVICE 
AUTHOR: I HAVE FOUND CYSTS.
PEOPLE: OH I WANT TO JOIN.
READER AGREES TO USE THESE FILES TO MAKE MONEY.
"""
INSTALLS="""
  altgraph==0.17
  argcomplete==1.10.0
  backcall==0.2.0
  beautifulsoup4==4.8.0
  bitly-api==0.3
  bs4==0.0.1
  cachetools==4.2.1
  certifi==2020.12.5
  cffi==1.14.5
  chardet==3.0.4
  clarifai==2.6.2
  click==7.1.2
  colorama==0.3.9
  colored==1.3.93
  colormath==3.0.0
  configparser==3.5.0
  cryptography==3.4.6
  curlify==2.2.1
  cycler==0.10.0
  decorator==4.4.2
  dicttoxml==1.7.4
  dill==0.3.3
  docx2txt==0.8
  EasyProcess==0.3
  EbookLib==0.17.1
  emoji==0.5.1
  et-xmlfile==1.0.1
  extract-msg==0.23.1
  facebook-business==3.3.0
  facebookads==2.11.4
  feedparser==5.2.1
  fonttools==3.29.0
  future==0.18.2
  gast==0.2.0
  google-api-core==1.3.0
  google-api-python-client==1.6.4
  google-auth==1.5.1
  google-auth-httplib2==0.0.4
  google-auth-oauthlib==0.2.0
  google-images-download==2.3.0
  googleapis-common-protos==1.5.3
  grpcio==1.35.0
  gspread==0.6.2
  gTTS==2.0.1
  gTTS-token==1.1.4
  html5lib==1.0.1
  httplib2==0.10.3
  idna==2.10
  imageio==2.9.0
  imageio-ffmpeg==0.4.3
  IMAPClient==2.1.0
  imgkit==1.0.1
  imgurpython==1.1.7
  instapy==0.6.2
  ipython==7.20.0
  ipython-genutils==0.2.0
  jdcal==1.4.1
  jedi==0.18.0
  jsonschema==2.6.0
  keyring==22.0.1
  kiwisolver==1.3.1
  lxml==4.6.2
  matplotlib==3.3.4
  MeaningCloud-python==2.0.0
  moviepy==1.0.0
  mtranslate==1.8
  multiprocess==0.70.11.1
  mutagen==1.40.0
  networkx==2.5
  numpy==1.20.1
  oauth2==1.9.0.post1
  oauth2client==4.1.2
  oauthlib==3.1.0
  olefile==0.46
  opencv-python==4.5.1.48
  openpyxl==2.5.4
  pandas==1.2.2
  parso==0.8.1
  pathlib2==2.3.2
  pathos==0.2.2.1
  pdf2image==1.1.0
  pdfminer.six==20181108
  pefile==2019.4.18
  pickleshare==0.7.5
  Pillow==8.1.0
  pip==21.0.1
  pkginfo==1.7.0
  playsound==1.2.2
  plyer==2.0.0
  pox==0.2.9
  ppft==1.6.6.3
  proglog==0.1.9
  prompt-toolkit==3.0.16
  protobuf==3.15.0
  psutil==5.8.0
  ptyprocess==0.6.0
  pyactiveresource==2.2.2
  pyasn1==0.4.8
  pyasn1-modules==0.2.8
  pycparser==2.20
  pycryptodome==3.10.1
  pydub==0.22.0
  Pygments==2.8.0
  pyinstaller==4.2
  pyinstaller-hooks-contrib==2020.11
  pyocr==0.5.2
  pyOpenSSL==20.0.1
  pyparsing==2.4.7
  PyPDF2==1.26.0
  pyperclip==1.6.0
  pypng==0.0.18
  pyreadline==2.1
  PySocks==1.6.8
  pytesseract==0.2.4
  python-dateutil==2.7.3
  python-docx==0.8.6
  python-pptx==0.6.18
  python-resize-image==1.1.11
  pytz==2017.3
  PyVirtualDisplay==0.2.1
  PyWavelets==1.1.1
  pywin32-ctypes==0.2.0
  PyYAML==5.4.1
  regex==2020.11.13
  requests==2.25.1
  requests-oauthlib==1.3.0
  requests-toolbelt==0.9.1
  rsa==4.7.1
  scikit-image==0.18.1
  scipy==1.6.1
  selenium==3.141.0
  setuptools==53.0.0
  ShopifyAPI==8.2.0
  six==1.12.0
  sortedcontainers==2.3.0
  soupsieve==2.2
  SpeechRecognition==3.8.1
  speedtest-cli==2.0.2
  termcolor==1.1.0
  text-to-image==0.0.5
  textract==1.6.3
  tifffile==2021.2.1
  tqdm==4.57.0
  traitlets==5.0.5
  twine==1.11.0
  tzlocal==1.5.1
  uritemplate==3.0.1
  urllib3==1.26.3
  virtualenv==16.0.0
  Wand==0.4.5
  wcwidth==0.1.7
  webcolors==1.7
  webdriverdownloader==1.1.0.3
  webencodings==0.5.1
  xlrd==2.0.1
  XlsxWriter==1.0.5
  xmltodict==0.11.0
  youtube-dl==2021.2.10
  """
for i in INSTALLS.split("\n"):
  #os.system("pip install ")
  1
def p0():
  "pip install pyobjc ==5.0"
def p1():
  """
  #i am pretty sure this is for 3.9.0 `virtual1`
  # Hey! She  did do the --upgrade .  
  #pip install pip --upgrade
  #pip install setuptools --upgrade
  #pip install ipython
  #pip install ShopifyAPI #820
  #pip install pandas
  #pip install pyinstaller
  #pip install termcolor #1.1.0
  #"youtube-dl"
  #"requests"
  #pip install twine==1.11.0
  #pip install facebook-business==3.3.0
  #pip install facebookads==2.11.4
  """
def p2():
  """
  pip install bs4==0.0.1
  pip install multiprocess
  pip install Pillow

  pip install keyring

  pip install selenium==3.14.1
  pip install pyperclip==1.6.0
  pip install colorama==0.3.9
  pip install colored==1.3.93
  pip install colormath==3.0.0
  pip install numpy #1.20.1

  pip install imgkit==1.0.1
  pip install imgurpython==1.1.7
  pip install instapy==0.6.2
  pip install moviepy==1.0.0 # not fully required
  pip install playsound==1.2.2
  pip install mtranslate
  pip install gTTS==2.0.1 # not fully required
  pip install sounddevice==0.3.10
  pip install speedtest-cli==2.0.2

  pip install configparser==3.5.0
  pip install dicttoxml==1.7.4
  pip install dill --upgrade
  pip install emoji==0.5.1
  pip install fonttools==3.29.0
  pip install gspread==0.6.2
  pip install pydub==0.22.0
  pip install PyPDF2==1.26.0
  pip install python-dateutil==2.7.3
  pip install python-docx==0.8.6
  pip install python-pptx==0.6.5
  pip install python-resize-image==1.1.11


  pip install google-api-core==1.3.0
  pip install google-api-python-client==1.6.4
  pip install google-auth==1.5.1
  pip install google-auth-httplib2
  pip install google-auth-oauthlib==0.2.0
  pip install google-images-download==2.3.0
  pip install googleapis-common-protos==1.5.3
  """
def part1():
  """
  pip install oauth2==1.9.0.post1
  pip install oauth2client==4.1.2
  pip install oauthlib --upgrade # 3.1.0
  pip install pyocr==0.5.2
  pip install pytesseract==0.2.4
  pip install text-to-image==0.0.5
  pip install textract

  pip install mutagen==1.40.0
  pip install pathos==0.2.2.1
  pip install imageio --upgrade #2.9.0
  pip install virtualenv==16.0.0
  pip install matplotlib --upgrade #3.3.4
  pip install bitly-api==0.3


  pip install pdf2image==1.1.0
  pip install psutil --upgrade #5.8.0
  pip install ptyprocess==0.6.0
  pip install pyparsing --upgrade #2.4.7
  pip install pypng==0.0.18
  pip install PySocks==1.6.8
  pip install pytz==2017.3
  pip install PyVirtualDisplay==0.2.1

  pip install html5lib==1.0.1
  pip install httplib2==0.10.3
  pip install lxml --upgrade #4.6.2
  pip install opencv-python --upgrade #4.5.1.48
  pip install openpyxl==2.5.4
  pip install scikit-image --upgrade #0.18.1
  pip install urllib3 --upgrade #1.26.3
  pip install wcwidth==0.1.7
  pip install webcolors==1.7
  pip install xlrd --upgrade # 2.0.1
  pip install XlsxWriter==1.0.5
  pip install xmltodict==0.11.0

  pip install feedparser==5.2.1
  pip install gast==0.2.0
  pip install pathlib2==2.3.2
  pip install Wand==0.4.5
  """
p0()
p1()
p2()
part1()
exec('import os')
exec('from time import sleep as sleep, sleep as zz, sleep as sp')
exec('from os import system, makedirs')
exec('from subprocess import Popen, getoutput, check_output')
exec('from facebook_business.adobjects.targetingsearch import TargetingSearch')
exec('from facebook_business.adobjects.targeting import Targeting')
exec('# from facebook_business.adobjects.reachestimate import ReachEstimate')
exec('from facebook_business.adobjects.customaudiencedatasource import CustomAudienceDataSource')
exec('from facebook_business.adobjects.customaudience import CustomAudience')
exec('from facebook_business.adobjects.campaign import Campaign')
exec('from facebook_business.adobjects.adset import AdSet')
exec('from facebook_business.adobjects.adpreview import AdPreview')
exec('from facebook_business.adobjects.adimage import AdImage')
exec('from facebook_business.adobjects.adcreativephotodata import AdCreativePhotoData')
exec('from facebook_business.adobjects.adcreativeobjectstoryspec import AdCreativeObjectStorySpec')
exec('from facebook_business.adobjects.adcreativelinkdata import AdCreativeLinkData')
exec('from facebook_business.adobjects.adcreative import AdCreative')
exec('from facebook_business.adobjects.adaccount import AdAccount')
exec('from facebook_business.adobjects.ad import Ad')
exec('from facebook_business import FacebookAdsApi')
exec('from datetime import timedelta, date, datetime')
exec('from collections import OrderedDict, Counter, defaultdict')
exec('import time')
exec('import sys')
exec('import subprocess')
exec('import shopify')
exec('import pyperclip')
exec('import pickle')
exec('try:import rumps\nexcept:print(2)')
exec('import requests as requests, requests as r, requests as hickey')
exec('import re')
exec('import random')
exec('import os')
exec('import json')
exec('import csv')
exec('import copy')
exec('import string')
g = lambda: globals()
rnd = round
ADSET_TESTING = False
Count = lambda l, x: l.count(x)
Database = "soda"
exec('GLOBAL_ADD_PRODUCT_NOTIFICATION = False')
GLOBAL_IMAGE_COMPARISON_TEST_SCORE = 0.9
GLOBAL_BROWSER_PAGEGOT_ZOOM_LEVEL = 2
GLOBAL_BROWSER_ELEMENT_WAIT_TIME = 3 # 7
GLOBAL_BROWSER_GET_PAGE_WAIT_TIME = 12 # 12 # requires 12
GLOBAL_BROWSER_URLWAIT_WAIT_TIME = 10 # 60
GLOBAL_BROWSER_PAGEGOT_WAIT_TIME = 3 # 5
GLOBAL_BROWSER_REQUIRE_SPEEDTEST = False
GLOBAL_BROWSER_STEP_SLEEPTIME = 0
GLOBAL_BROWSER_WINDOW_POSITION = [0, 0]
GLOBAL_BROWSER_WINDOW_SIZE = [1920, 600] # [1920, 1200]
GLOBAL_EMAILER_INITIALIZE_ERROR_MESSAGE = False
GLOBAL_FIREFOX_PROFILE_PATH = os.path.expanduser("~/Library/Application Support/Firefox/Profiles")
DOWNLOAD_VIDEO = False
WHILE_TRUE = 100000000
EMPTYSTRING = ""
Null = None

Exists = lambda address: os.path.exists(String(address))
Join = lambda *args: args[0].join(args[1])if(2==len(args))else(args[0].join(args[1:]))
Replacements = lambda s, *args, LOL={}: [setitem(LOL,"z",s),[setitem(LOL,"z",LOL["z"].replace(x,j)) for x,j in zip(args[0::2],args[1::2])] ,LOL["z"]][-1]
Split = lambda *args: (args[1].split(args[0]))if(len(args)==2)else(args[1].split(args[0],args[2]))
Strip = lambda s: s.strip()
Title = lambda s: s.title().replace("'S ","'s")

add = "globals().update(g.__dict__)"
midcmd = """process(lambda:[[OSA.log(str(tryreturn(lambda:eval(OSA.log("Func?"))(),ep=1)))]for i in(range(WHILE_TRUE)]))"""
subtract = "g.__dict__.update(globals())"
sys.setrecursionlimit(100000)
"""
if not os.path.exists(homepath("~/.matplotlib")):
  import imageio
  os.system("mkdir ~/.matplotlib && touch ~/.matplotlib/matplotlibrc && echo 'backend: agg' >> ~/.matplotlib/matplotlibrc")
  os.system("brew install ffmpeg &>/dev/null")
  os.system("brew install mysql &>/dev/null")
  imageio.plugins.ffmpeg.download()
  os.system("brew install mpv --with-libcaca &>/dev/null")
  os.system("asciiview")
  os.system("open ueiraweur.png")
  os.system("mpv fasdfs.jpg -vo caca")
"""
""" General-Utils """
def Copy(id,**kwargs):
  """
  This is used to copy an adset in Facebook Marketing. It is used to copy an adset when Facebook's ad set does not copy over.
  """
  # v3.3
  return [setitem(kwargs,"x",list(map(Integer,key("copied_id", [Shop()(All(Shop)[0].shop_abbreviation),json.loads(requests.post("https://graph.facebook.com/v3.3/%s/copies"%id, data={ "deep_copy":"true",
               "start_time":"%s 6:00:00 EST"%(Date().dt(0) if datetime.now().hour in [0,1,2] else Date().dt(1)),
               "status_option": "ACTIVE",
               "access_token": Shop.objects.all()[0].Facebook_Business_App_Token, }).content.decode())][1]["ad_object_ids"]))) ),
        [[AdSet(kwargs["x"][0]).remote_update(params={"status":"ACTIVE"}),Ad(kwargs["x"][1]).remote_update(params={"status":"ACTIVE"}),] if(2==len(kwargs["x"])) else [Campaign(kwargs["x"][0]).remote_update(params={"status":"ACTIVE"}),AdSet(kwargs["x"][1]).remote_update(params={"status":"ACTIVE"}),Ad(kwargs["x"][2]).remote_update(params={"status":"ACTIVE"}),] ],
        kwargs["x"],
  ][2]
def Exec(x,globals_,locals_):
  """
  This is a function used to execute a string.
  """
  globals().update(locals_)
  exec(x,globals())
def Float(x):
  """
  This is used to turn a string into a float.
  """
  return float(x)
def Integer(x):
  """
  This is used to turn a string into an integer.
  """
  return int(x)
def String(x):
  """
  This is used to turn 

  """
  return str(x)
def Ziff(*args):
  s, sep = args[0], args[1]
  maxsplit = -1 if len([i for i in args if type(i) == int])==0 else [i for i in args if type(i) == int][0]
  fncs = None if len([i for i in args if type(i) == list])==0 else [i for i in args if type(i) == list][0]
  y = s.split(sep,maxsplit)
  if fncs == None:
    return y
  else:
    y = [fncs[idx](i) for idx, i in enum(y)]
    return y
  """
  Ziff("x|y|z","|",[lambda i: i*2,lambda i: i*2,lambda i: i*2])
  Ziff("x|y|z","|")
  Ziff("x|y|z","|",1,[lambda i:i*2, lambda i: i*2])
  """
def add(x,y):
  globals()[x] += y
  return globals()[x]
def add_tag(x,y):
  if x == "" or x == None:
    x = y
  else:
    x += ", "
    x += y
  x = sorted(set(x.split(", ")))
  x = Join(", ", x)
  return x
  """
  add_tag("","Test")
  add_tag("Home","Test")
  add_tag("Home, Place","Test")
  """
def add_text_to_file(file, text, line_number):
  new_line_text = generate_one_random_number(5000)
  os.system("""sed -i "" -e '%ss/$/%s/' '%s'"""%(line_number,new_line_text,file))
  with open(file,"r") as f:
    new = f.read().replace(str(new_line_text),"\n"+text)
    open(file,"w").write(new)
def add_text_to_image(address,text,font=16,position=None):
  from PIL import Image, ImageDraw, ImageFont
  img = Image.open(address)
  d = ImageDraw.Draw(img)
  fnt = ImageFont.truetype("/Library/Fonts/Times New Roman.ttf", font)
  if not position:
    position = (5,5)
  d.text(position, text, font=fnt, fill=(0, 0, 0))
  img.save(address)
  return address
def added_list(*args):
  return flatten(args,1)
def address_backslash(address):
  return address.replace(" ", "\\ ")
def address_normalize(address):
  return(address)if(0==address.endswith("/"))else(address[:-1])
def and_list(*args):
  from types import MethodType,ModuleType,FunctionType
  latest = None
  for idx, arg in enum(args):
    if type(arg) == FunctionType or type(arg) == MethodType: arg = tryreturn(lambda:arg())
    else: arg = args[idx]
    latest = arg
    if arg == False or arg == 0 or arg == None or arg == [] or arg == () or arg == "" or arg == b"": return latest
  return latest
  """ ty moral_core on myfreecams """
def array_even(data, count):
  data2 = data
  for data in data2:
    while len(data)%count!=0:
      data.append("")
  return data2
def array_inner_even(data, delimiter="|"):
  for idx, i in enumerate(data):
    max_len = max(list(map(len, list(map(str, i)))))
    for idx2, j in enumerate(i):
      j = str(j)
      if(max_len!=len(j)):
        j = j + (delimiter*(max_len-len(j)))
        i[idx2]=j
  return data
def array_split(data, count, even=False):
  """
  array_split(lrange(45),10)
  [[0, 1, 2, 3, 4, 5, 6, 7, 8],
   [9, 10, 11, 12, 13, 14, 15, 16, 17],
   [18, 19, 20, 21, 22, 23, 24, 25, 26],
   [27, 28, 29, 30, 31, 32, 33, 34, 35],
   [36, 37, 38, 39, 40, 41, 42, 43, 44]]
  """
  import numpy as np
  data = list(data)
  if len(data) % count == 0:
    a = int(len(data)/count)
    b = list(range(0,len(data),a))+[len(data)]
    a_c = [data[i:i+a] for i in (b[:-1])]
    data = a_c
  else:
    return array_split1(data, count)
  data = list(map(list, data))
  return array_even(data) if(True==even) else(data)
def array_split1(data, count, even=False):
  """
  array_split1(lrange(45),10)
  [[0, 1, 2, 3, 4, 5, 6, 7, 8],
   [9, 10, 11, 12, 13, 14, 15, 16, 17],
   [18, 19, 20, 21, 22, 23, 24, 25, 26],
   [27, 28, 29, 30, 31, 32, 33, 34, 35],
   [36, 37, 38, 39, 40, 41, 42, 43, 44]]
  """
  import numpy as np
  data = np.array(data)
  data = np.array_split(data, (int(len(data)/count)+1))
  data = list(map(list, data))
  return array_even(data) if(True==even) else(data)
def array_split2(data, count):
  """
  array_split2(lrange(45),10)
  [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
   [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
   [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
   [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
   [40, 41, 42, 43, 44]]
  """
  x = []
  y = len(data) % count
  z = []
  i = 0
  z.append(data[0:count]) if int(len(data)/count) == 0 else "`"
  for i in range(int(len(data)/count)):
    z.append(data[i*count:(i+1)*count])
  z.append(data[(i+1)*count:]) if ""!=data[(i+1)*count:] else "`"
  return z
def apilimitcall(x, sleeptime = 5):
  try:
    # [(x.__call__()())if(x.__name__=="<lambda>")else(x.__call__()),blueprint("success")][0]
    return [(x.__call__())if(x.__name__=="<lambda>")else(x.__call__()),blueprint("success")][0]
  except Exception as e:
    blueprint("error: %s; sleeping %s" % (e, sleeptime))
    [[blueprint("waiting: %s\r"%(i+1),end=""),time.sleep(1)] for i in range(sleeptime)]
    sleeptime = sleeptime + 5
    return apilimitcall(x, sleeptime = sleeptime)
  """
  x = lambda: (0/0) if random.random() > 0.5 else ()
  apilimitcall(x)
  """
def assert_dialog(lambda_function, notification):
  try:
    assert lambda_function()
  except:
    OSA.display_dialog(notification, text_prompt = False, buttons = ["OK"])
def bind(obj,name,method):
  from types import MethodType,ModuleType,FunctionType
  setattr(obj, name, MethodType(method,obj))
def bind2(obj, name):
  from types import MethodType,ModuleType,FunctionType
  setattr(obj, name, MethodType(globals()[name],obj))
def bind3(obj,func):
  from types import MethodType,ModuleType,FunctionType
  setattr(obj, func.__name__, MethodType(func,obj))if("<lambda>"!=func.__name__)else(setattr(obj, get_lambda_name(func), MethodType(func,obj)))
def bindm(x,**kwargs):
  [bind(x,a,b) for a,b in kwargs.items()]
  return x
  """
  bindm(AD(),test = lambda self: print(1)).test()
  """
def binded_update(x,y):
  lmap(lambda i: bind(x,*i), y.items())
  """
  x= AttrDict()
  y={"croak": lambda self:print("croaks"),"moof":lambda self:print("moofs")}
  binded_update(x,y)
  x.croak()
  x.moof()
  """
def brewlist(versions=False):
  """
  --versions, you get 1.20.1_4, not necessarily what's in brew search. seems that you tended to use latest version.
  """
  return getoutput("brew list").split("\n")if(versions==False)else(lmap(lambda x: x.replace(" ", "@"), getoutput("brew list --versions").split("\n")))
  """
  brewlist(versions = False)
  brewlist(versions = True)
  """
def brightness(lvl):
  OSA("System Events", ['brightness %s'%lvl])
def button_up(x=None,y=None,z=None,cork=None,headors=None):
  if cork: return [dict(zip(lmap(re_spaces,key('text',headors(x))),lmap(re_spaces,key('text',i)))) for i in array_split(cork(x),int(len(cork(x))/len(headors(x))) )]
  return dict(zip(lmap(lambda i: re_spaces(i), key("text",y(x))),lmap(lambda i: re_spaces(i), key("text",z(x)))))
def ceil(x):
  import math
  return math.ceil(x)
def check_option(option):
  option = option.title()
  if "Size" not in option and "Material" not in option and "Capacity" not in option and "Height" not in option and "Model" not in option:
    return True
  else:
    return False
def check_output(x):
  return or_list(lambda:subprocess.check_output(x,shell=True).decode()[:-1],lambda:subprocess.getoutput(x))
def choice(x):
  return random.choice(x)
def cm_to_inch(s):
  if "cm" not  in s: return s
  try:
    cm_findings = re.findall(r" [0-9]*?cm", s)
    for cm_finding in cm_findings:
      x = cm_finding.replace("cm","")
      x = int(x)
      inch_measurement = x / 2.54
      inch_measurement = round(inch_measurement, 1)
      print("cm_to_inch finding: %scm to %sin" % (x, inch_measurement))
      s = s.replace(cm_finding, "%sin"%inch_measurement)
    print("[NOTE] function cm_to_inch --questionable use-- ")
  except Exception as e:
    print("cm to inches error: %s" % e)
    print(s)
  return s
def cm_to_inch2(s):
  if "cm" not in s: return s
  __original__ = s
  try:
    s = " " + s
    cm_findings = re.findall(r"( .*?cm)", s)
    for cm_finding in cm_findings:
      original = cm_finding
      cm_finding = cm_finding.replace("cm", "")
      cm_finding = cm_finding.split(" ")[-1]
      numbers = re.findall(r"[^0-9]*([0-9]*)",cm_finding)
      tmp = []
      print("tmp numbers: %s" % numbers)
      for i in numbers:
        try: tmp.append(int(i))
        except Exception as e: print("error: %s, %s" % (i,e))
      numbers = tmp
      print("numbers after tmp: %s" % numbers)
      numbers = [str(i) for i in numbers]
      the_inch_copy = str(original)
      for i in numbers:
        rounded = round((int(i)/2.54), 1)
        rounded = str(rounded)
        the_inch_copy = the_inch_copy.replace(i, rounded)
        print("cm: %s; rounded: %s" % (i, rounded))
      print("new 'original' : %s" % the_inch_copy)
      the_inch_copy = the_inch_copy.replace("cm", "in")
      s = s.replace(original, the_inch_copy)
      s = s.strip()
    print("===\n\n===== now showing comparison..")
    print("original: %s" % __original__)
    print("\n\n")
    print("s: %s" % s)
    print("\n\n")
    input("is this okay?: ")
    return s
  except Exception as e:
    print("erorrror : %s" % e)
def cm_to_inch3(s):
  s = Replacements(s, "2XL", "XXL", "3XL", "XXXL", "4XL", "XXXXL", "5XL", "XXXXXL", "6XL", "XXXXXXL")
  swizes = re.findall(r"[0-9]+",s)
  swizes = pool(Integer, swizes).result()
  swizes_ = pool(lambda i: wall((i/2.54)), swizes).result()
  s = Replacements(s, *list(map(str,sum(list(map(list,zip(swizes,swizes_))),[]))))
  return s
def cm_to_inch4(a):
  return a
  w = findall(a,"[\d\.]+cm")
  if w:
    x = findall(a,"[\d\.]+cm")
    assert len(x) == 1
    y = findall(a,1,"[\d\.]+cm")
    z = int(findall(y,1,"([\d\.]+)cm"))
    z = round(float(z)/2.54,2)
    z = str(z)
    if z.endswith(".0"):
      z = str(z).split(".")[0]
    replacement_string = "{}in".format(z)
    return re.sub("([\d\.]+cm)",replacement_string,a)
  else:
    return a
def compare_dict(a,b):
  x=""
  x+="{"
  x+="\n"
  for c,d in a.items():
    x+="    "
    x+="'%s': "%(c)
    if d != b[c]:
      x+="'%s' -> '%s',"%(d,b[c])
    else:
      x+="'%s'"%(d)
    x+="\n"
  x+="}"
  print(x)
  return x
  """
  compare_dict(
  {'ali_url': 'url',
  'fulfilled quantity': 0,
  'idx': 0,
  'shipping_address': 'Shipping Address, City, State, Zip Code',
  'sku': 'sku',
  'title': 'title',
  'total quantity': 0,
  'variant_title': ''},
  {'ali_url': 'url',
  'fulfilled quantity': 1,
  'idx': 0,
  'shipping_address': 'Shipping Address, City, State, Zip Code',
  'sku': 'sku',
  'title': 'title',
  'total quantity': 1,
  'variant_title': ''}
  )
  """
def copy_details():
  pyperclip.copy("dsthingasdf@protonmail.com asdfghjkASDFGHJK in the drafts folder")
def copypickles(x,y):
  import shutil
  shutil.copy(x,y)
def create_directories(*args):
  for idx,i in enum(args):
    os.makedirs("/".join(args[:idx+1]),exist_ok=True)
  """
  create_directories("a","b")
  rm("a")
  """
def create_pypi_package(file_in,readme_text,desc,version,install_requires,author,author_email):
  basic_license = "Python. Free to use no attribution required."
  name = file_in.replace(".py","")
  #version = "0.1.0"
  long_description = desc
  #author = "pleasefeedme"
  #uthor_email = "SpamNewsTable@protonmail.com"
  license = basic_license
  packages = [file_in.replace(".py","")]
  #install_requires = []
  os.makedirs(name)
  os.chdir(name)
  open("LICENSE.txt","w").write(basic_license)
  open("README.md","w").write(readme_text)
  open("setup.py","w").write(
  """from setuptools import setup
setup(
name='%s',
version='%s',
long_description='%s',
author='%s',
author_email='%s',
license='%s',
scripts=['%s'],
install_requires=%s)
"""%(name,version,long_description,author,author_email,basic_license,file_in,install_requires))
  import shutil
  shutil.copy("../%s"%(file_in),"./")
  open("__init__.py","w").write("from .%s import *"%(name))
  os.system("python setup.py sdist")
  os.system("twine upload dist/*")
def csed(r="class",s="class"):
  greenprint("the use of ' is not supported")
  s = s.replace('"','\\"').replace("'","\\'")
  blueprint(re.findall(r, open(__file__).read(), flags=re.MULTILINE))
  os.system("""sed -i '' -e 's/%s/%s/g' %s"""%(r,s,__file__))
def csv_table_to_html(table):
  data = '<table border="1">'
  data +=  '<tbody>'
  numerical_row = 0
  for row in table:
    data += "<tr>"
    numerical_col = 0
    for cell in row:
      data+= ("""<th style="text-align: center; color: #000000;">%s</th>"""%cell) if (numerical_row == 0\
        or numerical_col == 0) else ("""<td style="text-align: center;">%s</td>"""%cell)
      numerical_col += 1
    numerical_row += 1



    data += "</tr>"
  data += "</tbody>"
  data += "</table>"
  return data
def csv_table_to_png(bux):
  address = str(homepath("~/tavern/tavern/soda/dls/%s.csv"%random.randrange(99999999))).zfill(len("99999999"))
  csv.writer(open(address,"w")).writerows(bux)
  import pandas as pd
  df = pd.read_csv(address)
  os.remove(address)
  htmTable = df.to_html()
  load = re.sub(r"[\n\t]","",htmTable)

  import cv2
  reds = html_to_png(load)
  q = cv2.imread(reds)
  quinces = []
  for x in range(q.shape[1]):
    y = q[0:,x]
    print(x, y.shape, set(y.flatten()))
    if set(y.flatten()) == {255}:
      quinces.append(x)


  quinces = list(reversed(quinces))
  zealous = None
  for greater, lesser in zip(quinces[0:], quinces[1:]):
    if (greater-lesser) != 1:
      zealous = greater+10
      break
  redprint(zealous)
  v = q[0:,0:zealous]

  address = str(homepath("~/tavern/tavern/soda/dls/%s.png"%random.randrange(9999999999))).zfill(len("9999999999"))
  cv2.imwrite(address, v)
  impreview(address)
  return address
def date_of_birth_drawer(date_of_birth, m_num = False):
  date_of_birth = String(date_of_birth)
  date_of_birth = date_of_birth.zfill(8)
  m, d, y = ["January","February","March","April","May","June","July","August","September","October","November","December"].__getitem__(Integer(date_of_birth[:2])-1)if(m_num==False)else(date_of_birth[0:2]), date_of_birth[2:4], date_of_birth[4:]
  return m, d, y
def dataframe_to_dictlist(dataframe):
  dictlist = []
  headers = list(dataframe)
  data = dataframe.to_dict()
  data_len = len(data[headers[0]])
  for idx in range(data_len):
    e = {}
    for header in headers:
      e[header] = data[header][idx]
    dictlist.append(e)
  return dictlist
def datetime_math(x, **kwargs):
  return x + timedelta(**kwargs)
def dbsed(s="",r=""):
  csed(r, s)
def deepcopy(x):
  return copy.deepcopy(x)
def delete_adset(adset_id):
  Del(Get(Adset,adset_id=adset_id))
def delete_adsets():
  a_shop()
  for i in All(Adset):
    if AdSet(i.adset_id).remote_read(fields=["status"])["status"] == "ARCHIVED":
      print("Deleting one adset")
      Del(i)
      lmap(Del,Filter(Adsetinsight,adset_id=i.adset_id))
def delete_data():
  lmap(Del,All(AceInTheHole))
  lmap(Del,All(AceInTheHoleType))
  lmap(Del,All(AceInTheHoleTypeTag))
  lmap(Del,All(Adset))
  lmap(Del,All(Aliexpress_Dispute))
  lmap(Del,All(Aliexpressorder))
  lmap(Del,All(Aliexpressorder_event))
  lmap(Del,All(ApprovedTransaction))
  lmap(Del,All(Facebookadaccountspend))
  lmap(Del,All(GhostProduct))
  lmap(Del,All(GhostProductUpdate))
  lmap(Del,All(Keep_Exchange))
  lmap(Del,All(Lineitem))
  lmap(Del,All(New_Email))
  lmap(Del,All(Order))
  lmap(Del,All(Payment))
  lmap(Del,All(Payout))
  lmap(Del,All(Product))
  lmap(Del,All(ProductTalk))
  lmap(Del,All(ReOrder))
  lmap(Del,All(Settlement))
  lmap(Del,All(Soup))
  lmap(Del,All(Video))
  lmap(Del,All(TertiaryAction))
  lmap(Del,All(ProductsFeed))
  lmap(Del,All(LineitemsFeed))
def delete_last():
  Del(All(RandomGeneratedWords).n(-1))
def dictfromkeys(headers, default_value, ordered=False):
  x = dict(zip(headers, [default_value for header in headers]))if(ordered==False)else(OrderedDict(zip(headers, [default_value for header in headers])))
  return x
def dictrecurse(attrdict):
  for k,v in attrdict.items():
    if type(v) == AttrDict:
      attrdict[k] = dictrecurse(attrdict[k])
  return dict(attrdict)
def dictupdate(x,**kwargs):
  x.update(**kwargs)
  return x
def decimal_re(x):
  return Integer("".join(re.findall(r"\d+", x)))
def delete_keys(x,*args):
  for i in args:
    tryprocess(lambda: x.__delitem__(i))
  return x
  """
  a = {"a":"b","c":"d",}
  delete_keys(a,"a","c")
  """
def dictionarymeaning(x):
  from nltk.corpus import wordnet
  y = sudby(lambda i:i.name().split(".")[0]==x,wordnet.synsets(x))
  z = ifelseget(lambda:len(y) == 0,lambda:or_list(lambda:"Definition using Mirriam Webster. %s"%(re_substitute(random.choice(SOUPY(requests.get("https://www.merriam-webster.com/dictionary/%s"%(x)).text,"span","class","dtText")).text.split(": ")[1],["\s+"," "])),lambda:"No definition found for %s"%(x)),lambda:random.choice(y).definition())
  return z
def dictjoin(*args,**kwargs):
  x = {}
  for i in args:
    x.update(i)
  return x
def dicttoxml(x):
  import dicttoxml
def diff(x,y):
  x_, y_ = x, y
  x, y = lmap(lambda i:open(i).read().split("\n"),[x,y])
  diffs = []
  for i in x:
    if i in y:
      y.pop(y.index(i))
    else:
      diffs.append(i)
  x, y = lmap(lambda i:open(i).read().split("\n"),[x_,y_])
  for i in y:
    if i in x:
      x.pop(x.index(i))
    else:
      diffs.append(i)if(i not in diffs) else ()
  print(len(diffs))
  return diffs
def dip(x, y=1):
  for i in range(y):
    try:
      x = sum(x,[])
    except Exception as e:
      x = x
  return x
def dictxml(x,tcer=False):
  if tcer == False:
    import dicttoxml
    y = dicttoxml.dicttoxml(x)
    #y = y[0:39] + y[45:len(y)-7]
    return y
  else:
    import xmltodict
    y = xmltodict.parse(x)
    return y
def dkey(x):
  return list(x.items())[0][0]
  """
  dkey({"a":"b"})
  """
def dl(x):
  return Images().download(x)
def draw_circular_pay_chart():
  length = 45
  x = np.full(tuple(([length]*2)+[3]),[255,255,255])
  coordinates = []
  y = 0
  for i in range(length):
    coordinates.append((y,length-y-1))
    y += 1
  y = 0
  for i in range(length):
    coordinates.append((y,-(length-y)+1))
    y += 1
  y = 0
  for i in range(length):
    coordinates.append((-y,length-y-1))
    y += 1
  y = 0
  for i in range(length):
    coordinates.append((-y,-(length-y)+1))
    y += 1
  for i in coordinates:
    x[i[0]][i[1]] = np.array([0,0,0])
def droll(x):
  assert x() == True
def dt(x=0, strf='%Y-%m-%d'):
  return (datetime.now() + timedelta(x)).strftime(strf)
def dune(*args):
  x, y = args[0], args[1]
  x = [y[idx](i) for idx,i in enum(x)]
  return x
  """
  dune("a, 2, 3".split(", "), [lambda i: i*2, lambda i:int(i)+2, lambda i:int(i)+5])

  """
def dvalue(x):
  return list(x.items())[0][1]
  """
  dvalue({"a":"b"})
  """
def emoji_viewer():
  os.system("""osascript -e 'tell application "System Events" to key code 49 using {control down, command down}' """)
def enum(x):
  return enumerate(x)
def eye_exam():
  print("visit:  https://www.personaleyes.com.au/online-eye-test/index.php")
  print(" 1m away, 6 questions are asked  ")
def extract_emojis(str):
  import emoji
  return ''.join(c for c in str if c in emoji.UNICODE_EMOJI)
def filter(objects, *args, **kwargs):
  from django.db.models.query_utils import Q
  objects = [AttrDict(i) if type(i)==dict else i for i in objects]
  data = []
  for i in objects:
    to_append = 1
    for attr, value in kwargs.items():
      attr_arg = None
      if "__" not in attr:
        attr_arg = "equals"
      elif "__" in attr and attr.split("__")[1] == "contains":
        attr_arg = "contains"
      elif "__" in attr and attr.split("__")[1] == "icontains":
        attr_arg = "icontains"
      elif "__" in attr and attr.split("__")[1] == "range":
        attr_arg = "range"

      attr=((attr)if("__" not in attr)else(attr.split("__")[0]))

      if attr_arg == "equals" and not (getattr(i,attr) == value):
        to_append = 0
      if attr_arg == "contains" and not (value in getattr(i,attr)):
        to_append = 0
      if attr_arg == "icontains" and not (value.lower() in getattr(i,attr).lower()):
        to_append = 0
      if attr_arg == "range" and not (getattr(i,attr) >= value[0] and getattr(i,attr) <= value[1]):
        to_append = 0

      
    if(1==to_append):
      data.append(i)

  #data = []
  #args = [~Q(x=5),~Q(y=5)]
  #args = [~Q(x=5,y=5),]
  #data = lmap(AD,[{"x":5,"y":5},{"x":5,"y":4},{"x":4,"y":5},{"x":4,"y":4}])
  #new = []
  #for i in data:
  #  to_append = True
  #  for j in args:
  #    for k, l  in j.children:
  #      print(i, j, k, l)
  #      if getattr(i, k) == l:
  #        to_append = False
  #        print(getattr(i,k), l)
  #  if to_append == True:
  #    print(i)
  #    new.append(i)
  
  #new = []
  #for i in data:
  #  to_append = [True for i in range(len(args))]
  #  idx = 0
  #  for j in args:
  #    for k, l  in j.children:
  #      print(i, j, k, l)
  #      if getattr(i, k) == l:
  #        to_append[idx] = False
  #        print(getattr(i,k), l)
  #    idx += 1
  #  if set(to_append) == {True}:
  #    print(i)
  #    new.append(i)
  if args:
    new = []
    for i in data:
      to_append = [True for i in range(len(args))]
      idx = 0
      for j in args:
        all_signifiers = [True for i in range(len(j.children))]
        idx_2 = 0
        for k, l  in j.children:

          attr_arg = None
          if "__" not in k:
            attr_arg = "equals"
          elif "__" in k and k.split("__")[1] == "contains":
            attr_arg = "contains"
          elif "__" in k and k.split("__")[1] == "icontains":
            attr_arg = "icontains"
          elif "__" in k and k.split("__")[1] == "range":
            attr_arg = "range"

          attr=((k)if("__" not in k)else(k.split("__")[0]))
          value = l

          if attr_arg == "equals" and (getattr(i,attr) == value):
            all_signifiers[idx_2] = False
          if attr_arg == "contains" and (value in getattr(i,attr)):
            all_signifiers[idx_2] = False
          if attr_arg == "icontains" and (value.lower() in getattr(i,attr).lower()):
            all_signifiers[idx_2] = False
          if attr_arg == "range" and (getattr(i,attr) >= value[0] and getattr(i,attr) <= value[1]):
            all_signifiers[idx_2] = False

          #if getattr(i, k) == l:
          #  #to_append[idx] = False
          #  all_signifiers[idx_2] = False
          #  print(getattr(i,k), l)
          idx_2 += 1
        if set(all_signifiers) == {False}:
          to_append[idx] = False
        idx += 1
      if set(to_append) == {True}:
        new.append(i)

    data = new
  return data
  """
  assert filter([{"a":5,"b":2},{"a":4,"b":3}],~Q(a=5)) == [{'a': 4, 'b': 3}]
  assert filter([{"a":5,"b":2},{"a":4,"b":3}],~Q(a=5),~Q(b=3)) == []
  assert filter([{"a":5,"b":2},{"a":4,"b":3}],~Q(a=5),~Q(b=2)) == [{'a': 4, 'b': 3}]
  assert filter([{"a":5,"b":2},{"a":4,"b":3},{"a":5,"b":5}],~Q(a=5)) == [{'a': 4, 'b': 3}]
  assert filter([{"a":5,"b":2},{"a":4,"b":3},{"a":5,"b":5}],~Q(a=5,b=5)) == [{'a': 5, 'b': 2}, {'a': 4, 'b': 3}]
  """
def filter_in(a, b, mode="show_not_there"):
  assert len(oset(a)) == len(a)
  assert len(oset(b)) == len(b)
  if mode == "show_not_there":
    x = []
    for i in a:
      if i in b:
        x.append(i)
    y = []
    for i in b:
      if i not in x:
        y.append(i)
    return y
  elif mode == "show_there":
    x = []
    for i in a:
      if i in b:
        x.append(i)
    return x
  """
  filter_in([1,2,3],[1,2,3,4],"show_not_there")
  filter_in([1,2,3],[1,2,3,4],"show_there")
  filter_in([1,2,3,5],[1,2,3,4,5,6],"show_not_there")
  """
def findall(s, r, x=None):
  return (re.findall(r, s))if(len(listminus(locals().values(),None))==2)else(re.findall(x, s)[0])if(len(listminus(locals().values(),[[]]))==3)else()
def flatten(x, y=1):
  for i in range(y):
    try:
      x = sum(x,[])
    except Exception as e:
      x = x
  return x
def floor(x):
  import math; return math.floor(x)
def flt(x):
  return float(x)
def font_preview(address):
  from PIL import Image, ImageDraw, ImageFont
   
  img = Image.new('RGB', (1800, 540), color = (255, 255, 255))
   
  fnt = ImageFont.truetype(address, 45)
  d = ImageDraw.Draw(img)
  d.text((10,10), "[{}] Hello world. Untitled `404`.liquid ~`!@#$%^&*()_+-=[]\\|;':<>,.?/Seven Six Five Four".format(address.split("/")[-1]), font=fnt, fill=(0, 0, 0))
   
  img.save('pil_text_font.png')
  impreview('pil_text_font.png')
  os.system('rm pil_text_font.png')
def free_plus_ship(x):
  CH().free_plus_ship(x)
def fuckmachine(key):
  return globe("key")
def generate_keylogger():
  times, keys = [], []
  file = open(homepath("~/hole/hole/keylogger/logfile.log")).read().split("\n")[:-1]
  file = sudby(lambda i: i.split(" ",1)[1][0] != "[", file)
  for i in file:
    time, key = i.split(" ",1)
    times.append(time)
    keys.append(key)
  time, letters, current_load, on = None, "", "", False
  current_loads = []
  for i, j in zip(times,keys):
    letters = letters + j
    time = i
    if letters.endswith("ss-"):
      on = True
    if on == True:
      current_load = current_load + j
    if letters.endswith("-ee"):
      on = False
      time = i
      current_load = current_load[2:-3]
      print(current_load)
      current_loads.append([time, current_load])
      time = datetime.fromtimestamp(int(time))
      tp(lambda:Save(Note,note=current_load,time=time))
      letters = ""
      current_load = ""
  # if os.path.getsize(homepath("~/hole/hole/keylogger/logfile.log")) > 7432790:
  #   x = open(homepath("~/hole/hole/keylogger/logfile.log"),"r").readlines()
  #   num_lines = int(len(x)/2)
  #   y = x[:num_lines]
  #   open(homepath("~/hole/hole/keylogger/logfile.log"),"w").write("".join(y))
  time.sleep(60)
  ifdo(lambda:random.randrange(1,61) == 60,lambda:os.system("killall keylogger"))
  generate_keylogger()
  # return current_loads
def generate_one_alphabetical_string(size=10):
  import string
  w = (" ".join(string.ascii_letters)).split(" ")
  x = ""
  for i in range(size):
    x += random.sample(w,1)[0]
  return x
def generate_one_alphanumeric_string(size=10):
  import string
  w = (" ".join(string.ascii_letters)).split(" ") + list(map(str,list(range(10))))
  x = ""
  for i in range(size):
    x += random.sample(w,1)[0]
  return x
def generate_one_random_number(digits):
  x = ""
  while True:
    x = x + str(random.choice(list(range(10))))
    if len(x) == digits:
      return x
def generator(x):
  return (i for i in x)
def getattrs(attrs,x):
  return [getattr(x,i) for i in attrs]
def getitems(items,x):
  return [getitem(x,i) for i in items]
def getpass(x = None):
  from getpass import getpass
  return getpass()if(x==None)else(getpass(x))
def getsafarisource():
  blueprint("Safari -> Advanced -> Show develop menu ; Develop -> Allow JavaScript from Apple Events")
  x = subprocess.check_output("""osascript -e 'tell application "Safari" to set my_html to source of document 1'""",shell=True).decode("utf-8",errors="backslashreplace")
  return x
def getsafariurl():
  x = subprocess.getoutput("""osascript -e 'tell application "Safari" to set the_url to URL of current tab of window 1'""")
  return x
def getuser():
  import getpass
  return getpass.getuser()
def getwindowcount(x):
  return int(subprocess.getoutput("""osascript -e 'tell application "%s" to get (count of windows)'"""%x))
def get_active_shops():
  return Filter(Shop,Active=True)
def get_chmod_statuses():
  for i in os.listdir("/Applications"):
    status = subprocess.getoutput("stat -f '%OLp' '/Applications/{}'".format(i))
    print("%s: %s" % (i,status))
  for i in os.listdir("/Applications/Utilities"):
    status = subprocess.getoutput("stat -f '%OLp' '/Applications/Utilities/{}'".format(i))
    print("%s: %s" % (i,status))
def get_dircount(path=None):
  if path is None: path = os.path.expanduser('~/')+'Downloads'
  return len(os.listdir(path))
def get_feed():
  return get_user().remote_read(fields=["feed"]).export_all_data()["feed"]["data"]
def get_in_between_idx(new,x):
  chosen_idx = None
  for idx,i in enum(x[:-1]):
    if new > i and new < x[idx+1]:
      print(i,new,x[idx+1])
      chosen_idx = idx
  return chosen_idx
def get_one_address(directory,ext):
  return os.path.join(directory,"x")+(".%s"%(ext))
def get_random_address(directory):
  print("getting random address")
  class x(str):
    __init__ = lambda self, s: super().__init__()
    png = lambda self: self.__add__(".png")
    jpg = lambda self: self.__add__(".jpg")
    jpeg = lambda self: self.__add__(".jpeg")
    csv = lambda self: self.__add__(".csv")
    mp4 = lambda self: self.__add__(".mp4")
    txt = lambda self: self.__add__(".txt")
    txt = lambda self: self.__add__(".txt")
    txt = lambda self: self.__add__(".txt")
    txt = lambda self: self.__add__(".txt")
  c = x(generate_one_random_number(10))
  if c in lmap(lambda i: ".".join(i.split(".")[:-1]), os.listdir(directory)):
    return get_random_address(directory)
  c = x(os.path.join(directory,c))
  return c
def get_random_address2(directory,ext):
  x = random.randrange(10000000)
  return os.path.join(directory,str(x))+".%s"%(ext)
def get_random_from_lists(*args):
  firsts = args[:int(len(args)/2)]
  x = []
  x.append(firsts[0])
  for idx,i in enum(firsts[1:]):
    x.append(round(i+x[-1],2))
  new = random.random()
  x.insert(0,0)
  """
  while True:
    new = random.random()
    for idx,i in enum(x[:-1]):
      if new > i and new < x[idx+1]:
        print(i,new,x[idx+1])
        time.sleep(1)
  """
  choices = args[int(len(args)/2):]
  chosen_idx = get_in_between_idx(new,x)
  chosen_choices = choices[chosen_idx]
  return random.choice(chosen_choices)
def get_random_word():
  from nltk.corpus import words
  x = words.words()
  word = random.choice(x)
  return word
def get_lambda_name(l):
  return get_source(l).split("=")[0].strip()
def get_latest_download(path=None,x=0):
  import glob
  if path is None: path = os.path.expanduser('~/')+'Downloads'
  return sorted(glob.glob('%s/*' % path), key=os.path.getmtime, reverse=True)[x]
def get_product_url(x):
  url = "https://%s/admin/products/%s"%(Get(Shop,shop_abbreviation="rom").Domain_Name,x.id)
  return url
def get_size_of(x):
  return sys.getsizeof(x)
def get_source(x):
  from inspect import getsource
  return getsource(x)
def gethickey():
  session = requests.session()
  session.original_get = session.get
  def get(self,*args,**params):
    tp(lambda:MelaniaTrump().semlo().deflux().flux().jagged().didnt_you_deeptimeslotAffiliateMarketing().hiTo().thawk().symphony().isEnglishYet().IsLoL().Buy().Sell().Cuy().affiliation().greenpowderbomb().marketing().slice().fullarrest().cardiaclobotomy().pipesolarplexus().accumulateADDITIONALdiscontinuancies().slowlyoffsetroots___().wherewasit__().takefullpercentage().drivebyAndGiveTinnitusForAdditionalPercentage().InsertMurderererererererCCComPleXXX().affyliatemarketing())
    url = list(args).pop()
    url = re_substitute(url,["(?m)^https://",""])
    self.original_get(url)
  bind3(session,get)
  tp(lambda:MelaniaTrump().IsNowMelaniaTrump().RemoveTrump().Melania().ReplaceTrump().Trumpet().Crimp().Purchase().Toss().Rename().Ban().Diet())
  tp(lambda:MelaniaTrump().killherself().nobodyExists())
  tp(lambda:MelaniaTrump().Trash().IssueReinventionOfGameAndGirlsPerspectiveasswell())
  return session
def getitem(*args):
  return or_list(lambda:args[0].get(args[1],or_list(lambda:args[2],None)),lambda:or_list(lambda:args[0][args[1]],lambda:args[2]),lambda:(0/0))
def gl(x,a):
  globals()[a] = x
  """
  gl("5","test")
  print(gx("test"))
  """
def gleb(x,y=1):
  return (random.sample(x,1)[0])if(y==1)else(random.sample(x,y))
def globalise(x,a,**like_a_is_the_key):
  globals()[a] = x
def globalosis(x):
  globals().update(x)
def globalpacker(func,variable):
  if variable not in globals():
    globalise(func(),variable)
  return globals()[variable]
  """
  notentry(lambda:1,"b")
  assert globe("b") == 1
  """
def globe(x,*args):
  return (globals().get(x,*args))if(args)else(globals().get(x))
def go_over(x,y):
  x(y)
  return y
  """
  go_over(lambda i: print(i.a), AD(a=5))
  """
def got_ali_url():
  existing = lmap(lambda i: re.findall("\d+\.html",i.ali_url)[0],Filter(Product,ali_url__icontains="aliexpress.com"))
  urls_2 = lmap(lambda i: re.findall("\d+.html",i.url)[0],All(AddProduct))
  now = re.findall("\d+\.html",get_first_chrome_url())[0]
  if now in existing or now in urls_2:
    print("index: %s"%(shuffled(existing+urls_2).index(now)))
    print("now: %s" % now)
    return True
def gtts(mytext='Convert this Text to Speech in Python',language="en"):
  from gtts import gTTS
  import os
  #mytext = 'Convert this Text to Speech in Python'
  #language = 'en'
  myobj = gTTS(text=mytext, lang=language, slow=False)


  myobj.save("output.mp3")

  # Play the converted file
  os.system("start output.mp3")
  return "output.mp3"
def gx(x,*args):
  return (globals().get(x,*args))if(args)else(globals().get(x))
def homepath(x):
  import os
  return os.path.expanduser("~%s"%(x.split("~")[1]))
def html_test(x):
  open("test.html","w").write(str(x))
  system("/Applications/Firefox\ 46.app/Contents/MacOS/firefox-bin -p sele test.html &>/dev/null&")
def html_to_png(io):
  address_1 = homepath("~/tavern/tavern/soda/dls/._%s_tmp.html"%(random.randrange(10000000,99999999)))
  address_2 = homepath("~/tavern/tavern/soda/dls/._%s_out.png"%(random.randrange(10000000,99999999)))
  try:
    if os.path.exists(io):
      io = io
    else:
      try:
        try:open(address_1,"w",encoding="utf-8").write(io)
        except:open(address_1,"wb",encoding="utf-8").write(io)
      except Exception as v:
        v
      io = address_1
    try:
      os.system("""/usr/local/bin/wkhtmltoimage --disable-smart-width --javascript-delay 1000 --encoding utf-8 --load-error-handling ignore --load-media-error-handling ignore "%s" "%s" """%(address_1,address_2))
    except Exception as w:
      w
    tryprocess(os.remove,address_1)
    return address_2
  except Exception as e:
    e = str(e)
    OSA.log("MIGHTY_ERROR: %s"%e)
    return "MIGHTY ERROR"
def ifdo(x,y):
  if x():
    y()
  """
  ifdo(lambda: 1==1, lambda: print(5))
  ifdo(lambda: 1==2, lambda: print(5))
  ifdo(lambda: [], lambda: print(5))
  ifdo(lambda: True, lambda: print(5))
  """
def ifelsedo(x,y,z):
  if tryreturn(lambda:x()):
    return y()
  else:
    return z()
  """
  ifelsedo(lambda: 1==1, lambda: print(5), lambda: print(4))
  ifelsedo(lambda: 1==2, lambda: print(5), lambda: print(4))
  ifelsedo(lambda: [], lambda: print(5), lambda: print(4))
  ifelsedo(lambda: True, lambda: print(5), lambda: print(4))
  """
def ifelseget(x,y,z):
  if tryreturn(lambda:x()):
    return y()
  else:
    return z()
  """
  ifelseget(lambda: 1==1, lambda: print(5), lambda: print(4))
  ifelseget(lambda: 1==2, lambda: print(5), lambda: print(4))
  ifelseget(lambda: [], lambda: print(5), lambda: print(4))
  ifelseget(lambda: True, lambda: print(5), lambda: print(4))
  """
def ifelselist(*args):
  for i,j in zip(args[0::2],args[1::2]):
    if i():
      return j()
def ifget(x,y):
  if tryreturn(lambda:x()):
    return y()
def im2arr(fn):
  import numpy as np
  from PIL import Image
  return np.array(Image.open(fn))
def images_to_column_xlsx(images,column="A",image_size=100,**stars):
  import openpyxl
  wb = ifelseget(lambda:stars["wb"],lambda:stars["wb"],lambda:openpyxl.Workbook())
  ws = wb.worksheets[0]
  ws.column_dimensions['A'].width = (image_size/8)
  s = 1
  for i in images:
    img = openpyxl.drawing.image.Image(i)
    img.anchor = '%s%s'%(column,s)
    print('%s%s'%(column,s))
    ws.add_image(img)
    ws.row_dimensions[s].height = (image_size*0.75)
    s += 1
  wb.save('out.xlsx')
  return wb
def impreview(address, speed=0.3):
  if not os.path.exists(str(address)):
    import cv2
    os.makedirs(homepath("~/tavern/tavern/soda/dls"),exist_ok=True)
    a = (homepath("~/tavern/tavern/soda/dls/%s.png"%(generate_one_alphanumeric_string(18))))
    cv2.imwrite(a, address)
    address = a

  from PIL import Image
  if os.path.isdir(address):
    [[Image.open(os.path.join(address,fn)).show(), time.sleep(speed)] for fn in sorted(os.listdir(address))]
  else:
    Image.open(address).show()
def index(x, y):
  try:return list(x).index(y)
  except:return -1
def indicepick(x,y):
  return [y[i] for i in x]
  """
  indicepick([1,2,3], [1,2,3,4,5,6])
  """
def intcls(x,**kwargs):
  return type("a",(int,),kwargs)(x)
  """
  r = intcls(123,print = lambda self:print(self))
  r.print()
  """
def intify(x):
  return [int(i) if tp(lambda:int(i))==1 else i for i in x]
def itemcopy(a,b,f):
  redprint("Temporary Guide For Cloning: Keyse, GeheadN+(A),(B),(F);A^!TAKES FROM B, ITER<F>.")
  for zelish in f:
    rhondousel = getattr(b, zelish, None)
    setattr(a, zelish, rhondousel)
  a.save()
  return a
  """ ::: Tests ::: """
  """
  a = AttrDict()
  b = All(Product)[0]
  fields = ['size_chart', 'vendor', 'id', 'item_type']
  itemcopy(a,f,fields)
  """
def iterindex(xy, lox):
  x = []
  for i in xy:
    if i in lox:
      x.append(lox.index(i))
  return x
  """
  xy = [0,1,2,3,4,5,6]
  lox = [0,1,2,3,4,5,6,7,8,0,1,2,3]
  print(iterindex(xy, lox))
  xy = [0,1,2,3,4,5,6]
  lox = [7]
  print(iterindex(xy, lox))
  """
def key(dictlist, key):
  if type(dictlist) is str or type(dictlist) is int:
    dictlist, key = key, dictlist
  try: return [getattr(i, key) for i in list(dictlist)]
  except: return [i[key] for i in list(dictlist)]
def keyby(x,y):
  return or_list(lambda:[i for i in y if x(i)],lambda:[i for i in y if x(*i)],[])
def keycall(key, dictlist, *args, **kwargs):
  try: return [getattr(i, key)(*args, **kwargs) for i in list(dictlist)]
  except: return [i[key](*args, **kwargs) for i in list(dictlist)]
def keycontains(key, contains, dictlist):
  try: return [i for i in list(data) if contains in i[key]]
  except: return [i for i in list(data) if contains in getattr(i, key)]
def keyequals(key, equals, data):
  try: return [i for i in list(data) if i[key] == equals]
  except: return [i for i in list(data) if getattr(i, key) == equals]
def keyicontains(key, icontains, dictlist):
  try: return [i for i in list(data) if icontains.lower() in i[key].lower()]
  except: return [i for i in list(data) if icontains.lower() in getattr(i, key).lower()]
def keymulti(keys, dictlist):
  try: return [[getattr(a,b) for b in keys] for a in list(dictlist)]
  except: return [[getitem(a,b) for b in keys] for a in list(dictlist)]
def keynicontains(key, nicontains, data, ):
  try: return [i for i in list(data) if nicontains.lower() not in i[key].lower()]
  except: return [i for i in list(data) if nicontains.lower() not in getattr(i, key).lower()]
def keyncontains(key, ncontains, data, ):
  try: return [i for i in list(data) if ncontains not in i[key]]
  except: return [i for i in list(data) if ncontains not in getattr(i, key)]
def keynequals(key, nequals, data, ):
  try: return [i for i in list(data) if i[key] != nequals]
  except: return [i for i in list(data) if getattr(i, key) != nequals]
def keynotequals(key, notequals, data, ):
  try: return [i for i in list(data) if i[key] != notequals]
  except: return [i for i in list(data) if getattr(i, key) != notequals]
def keysort(key, dictlist, tcer=True):
  import operator
  if type(key) is not list:
    key = [key]
  try: return sorted(list(dictlist), key=operator.itemgetter(*key), reverse=tcer)
  except: return sorted(list(dictlist), key=operator.attrgetter(*key), reverse=tcer)
def keysort_multi(columns, items, tcer=False):
  from operator import itemgetter, attrgetter
  from functools import cmp_to_key
  comparers = None
  if tryprocess(lambda:items[0].get(columns[0])): comparers = [((itemgetter(col[1:].strip()), -1) if col.startswith('-') else (itemgetter(col.strip()), 1)) for col in columns]
  else: comparers = [((attrgetter(col[1:].strip()), -1) if col.startswith('-') else (attrgetter(col.strip()), 1)) for col in columns]
  def comparer(left, right):
    def cmp(a, b):
      if a == None and b == None: return 0
      if a == None and b != None: return 1        
      if a != None and b == None: return -1
      elif a != None and b != None: return (a > b) - (a < b)
    comparer_iter = ( cmp(fn(left), fn(right)) * mult for fn, mult in comparers)
    return next((result for result in comparer_iter if result), 0)
  return sorted(list(items), key=cmp_to_key(comparer), reverse=tcer)
def kodo(func, *args, ep=0, error = None, **kwargs):
  try:
    return func(*args, **kwargs)
  except Exception as e:
    OSA.log(str(or_list(error,e)))if(1==ep or error)else(1)
    return 0
  (0/0)
def ldict(x=None):
  return OrderedDict(x)if(x)else(OrderedDict())
def linspace(start, stop, precision, endpoint=False):
  start, stop = round(float(start),2), round(float(stop),2)
  roundpoint = len(str(precision).split(".")[-1])if(".") in str(precision) else 0
  d = []
  x = start
  while True:
    d.append(x)
    x = x + precision
    x = round(x, roundpoint)
    if x == stop:
      break
  if endpoint == True:
    d.append(x)
  return d
  """
  linspace(0.76, 1.01, 0.01)
  """
def list_and(*args):
  from types import MethodType,ModuleType,FunctionType
  latest = None
  for idx, arg in enum(args):
    if type(arg) == FunctionType or type(arg) == MethodType: arg = tryreturn(lambda:arg())
    else: arg = args[idx]
    latest = arg
    if arg == False or arg == 0 or arg == None or arg == [] or arg == () or arg == "" or arg == b"": return latest
  return latest
def listadd(*args):
  x = []
  for i in args:
    if "append" not in dir(i):
      i = [i]
    x.extend(i)
  return x
  """
  listadd([1,2,3],[1,2,3],["a","b","c"],[[1,2,3]])
  """
def listinsert(x,l1,l2):
  return l2[:x] + l1 + l2[x:]
  """
  assert listinsert(1,[4,5,6],[1,2,3]) == [1,4,5,6,2,3,]

  """
def listmap(func, *args, **kwargs):
  from functools import partial
  return list(map( partial(func, **kwargs), *args ))
def listminus(x,y=[],minus_once = False, **kwargs):
  # puts [] into a list.
  if "append" not in dir(y):
    y = [y]
  if minus_once == False:
    return [i for i in x if i not in y and kwargs.get("method",lambda i:True)(i)]
  else:
    for i in y:
      if i not in x:
        continue
      else:
        R = x.index(i)
        x.pop(R)
    return x
  """
  x = [2,1,2,1]
  y = [1]
  assert [2, 2] == listminus(x, y, minus_once = False)
  assert [2, 2, 1] == listminus(x, y, minus_once = True)
  """
def listplus(x,y,z):
  l = len(x)
  for i in range(y-l):
    x.append(z)
  return x
  '''
  listplus([1,2,3],5,None)
  '''
def listreplace(io, *args, **kwargs):
  return [setitem(kwargs,"z",io),[setitem(kwargs,"z",[i if i != x else j for i in kwargs["z"]]) for x,j in zip(args[0::2],args[1::2])] ,kwargs["z"]][-1]
def listshift(start=None,x=None):
  a = x[start]
  x.__delitem__(start)
  x = [a] + x
  return x
  """
  listshift(2,[1,2,3,4,5])
  """
def lmap(func, *args, **kwargs):
  from functools import partial
  arg_lens = oset([len(i) for i in args])
  assert len(arg_lens) == 1
  if arg_lens[0] == 0:
    return []
  # x = or_list(lambda:list(map( partial(func, **kwargs), *args )),
  #                 lambda:list(map( partial(func, **kwargs), *[[i[idx] for i in args[0]] for idx in list(range(oset(list(map(len,args[0])))[0]))]) ),
  #                 lambda: 0/0)
  x = or_list(lambda:list(map( partial(func, **kwargs), *args )),
                  lambda:list(map( partial(func, **kwargs), *transpose(args[0]) )),
                  lambda:0/0)
  ifdo(lambda:x==0,lambda:exec("assert False"))
  return x
  """
  assert lmap(lambda i,j: i+j, [(1,1),(2,2),(3,3)]) == [2, 4, 6]
  assert lmap(lambda i: i+1, [1,2]) == [2, 3]
  """
def lrange(*args):
  return list(range(args[0]))if(len(args)==1)else(list(range(args[0],args[1])))
def lset(x):
  return list(set(x))
def loadpickles(*args,**kws):
  ifdo(lambda:os.path.exists(args[0])==False,lambda:savepickles(kws['default'],args[0]) )
  return pickle.load(open(args[0],'rb'))
def login_prompt():
  OSA().log("Please log in. Then press OK. ",tp=False)
def lsorted(x,**kwargs):
  return sorted(x,key=kwargs.get("key",None),reverse=kwargs.get("tcer",False))
  """
  lsorted([5,2,3],tcer=True)
  lsorted([5,2,3],y=lambda i: i)
  lsorted([5,2,3],y=lambda i: i,tcer=True)
  """
def make_archive(address):
  import shutil
  import zipfile
  rm("%s.zip"%address)if(1==os.path.exists("%s.zip"%address))else(0)
  shutil.make_archive(address, 'zip', address) if os.path.isdir(address) else zipfile.ZipFile("%s.zip"%address, mode="w").write(address)
  return "%s.zip"%address
def methodsort(x, method, tcer=False):
  return sorted(x, key=method, reverse=tcer)
def microsecondize(a,b):
  c = (b-a)
  d = c.seconds
  v = c.microseconds / 1000000
  f = (d)+(v)
  return f
def mig(*args,**kwargs):
  SQL().migrate(*args,**kwargs)
def mkchdir(address):
  os.makedirs(address, exist_ok=True)
  os.chdir(address)
def msort(x, method, tcer=False):
  return sorted(x, key=method, reverse=tcer)
def multi_input(printout):
  distinct_print("====multi_input====:\n%s"%printout)
  x = ""
  while True:
    y = input("")
    if y[-2:] == "\Q":
      y = y[:-2]
    if y=="q":
      return x
    x += y
    x += "\n"
def multiprocessing_process(target):
  import multiprocessing
  R = multiprocessing.Process(target = target)
  R.start()
  return R
def mysql_args_and_kwargs_to_string(*args, **kwargs):
  import django
  stuff = []
  for i in args:
    if type(i) == django.db.models.query_utils.Q:
      x = i.children
      for idx_0, a in enum(x):
        x[idx_0] = list(a)

        for idx,b in enum(x[idx_0]):
          if b == True:
            x[idx_0][idx] = "true"
          elif b == False:
            x[idx_0][idx] = "false"

      for j in x:
        if "__" in j[0]:
          if "__icontains" in j[0]:
            stuff.append("%s not like '%%%s%%'"%(j[0].split("__")[0],j[0].split("__")[1]))
        else:
          stuff.append("%s!='%s'"%(j[0],j[1]))


  for a,b in kwargs.items():
    if a == True: a = "true"
    if a == False: a = "false"
    if "__" in a:
      if "__icontains" in a:
        stuff.append("%s like '%%%s%%'"%(a.split("__")[0],b))
    else:
      stuff.append("%s='%s'"%(a,b))


  stuff = "where" + " " + " and ".join(stuff)
  return stuff
def mysql_delete(x):
  """ This will work only if the id is an AutoField on any model with multiple unique fields. """
  #t = ('/usr/local/bin/mysql -u root --password=w24uyLMGU2TWdkBdUKMWySQiAcfdjB1A soda -e """delete from %s_%s where id="%s";"""&>/dev/null ' % (Database, x._meta.verbose_name.replace(" ",""), x.id))
  t = ("""/usr/local/bin/mysql -u root --password=w24uyLMGU2TWdkBdUKMWySQiAcfdjB1A soda -e "delete from %s_%s where id='%s';"&>/dev/null """ % (Database, x._meta.verbose_name.replace(" ",""), x.id))
  #redprint(t)
  os.system(t)
def mysql_exec(w="select count(*) from soda_timedtask;"):
  x = subprocess.getoutput("""mysql -u root --password=w24uyLMGU2TWdkBdUKMWySQiAcfdjB1A soda -e "%s" """ % ((w+";")if(not w.endswith(";"))else(w))).split("\n")[1:]
  x = [i.split("\t") for i in x]
  headers = x.pop(0)
  y = [dict(zip(headers, i)) for i in x]
  return y
def ner_tagger(text):
  from nltk.tag import StanfordNERTagger
  from nltk.tokenize import word_tokenize

  Binarydata().export("NER")
  
  st = StanfordNERTagger('NER/english.all.3class.distsim.crf.ser.gz',
               'NER/stanford-ner.jar',
               encoding='utf-8')

  tokenized_text = word_tokenize(text)
  classified_text = st.tag(tokenized_text)

  print(classified_text)

  x = []
  for i in classified_text:
    if i[1]=='PERSON':
      print(i)
      x.append(i[0])

  import shutil
  shutil.rmtree("NER")

  return x
def new_dict(x,fields=[]):
  return AD({a:b for a,b in x.items() if a in fields})
def notentry(a,b):
  if b not in globals():
    globalise(a(),b)
  return globals()[b]
  """
  notentry(lambda:1,"b")
  assert globe("b") == 1
  """
def notexists(x):
  if x != False and x != 0 and x != None and x != [] and x != () and x != "" and x != b"":
    return False
  else:
    return True
  """
  notexists("")
  """
def nps_chat_reader():
  from nltk.corpus import nps_chat
  for i in nps_chat.xml_posts():
    print(i.text)
    x = input("")
    if x == "quit":
      break
  return
def openr(address):
  return open(address)
def openw(address):
  return open(address, "w")
def openrb(address):
  return open(address, "rb")
def openwb(address):
  return open(address, "wb")
def ordered_json_dumps(x):
  return json.dumps(OrderedDict([[a,str(x[a])] for a in list(sorted(x.keys())) if not a.startswith("_")]), indent=4)
def or_list(*args):
  from types import MethodType,ModuleType,FunctionType
  for idx, arg in enum(args):
    if type(arg) == FunctionType or type(arg) == MethodType:
      arg = tryreturn(lambda:arg())
      if arg != False and arg != 0 and arg != None and arg != [] and arg != () and arg != "" and arg != b"":
        return arg
    if arg != False and arg != 0 and arg != None and arg != [] and arg != () and arg != "" and arg != b"":
      return args[idx]
  return (tryreturn(lambda:args[-1]()))if(type(args[-1])==FunctionType or type(args[-1])==MethodType)else(args[-1])
  """
  or_list(tryreturn(lambda: 3/1), "a", None, 0,)
  or_list(1,lambda:print(1),lambda:print(1))
  or_list(lambda:print(1),1,lambda:print(1))
  or_list(lambda:print(1),1)
  or_list(0,ExecutableText().export("hello"),1)
  or_list(0,lambda x=1: x)
  """
def oset(x, **kwargs):
  y = []
  for i in x:
    if i not in y:
      if i not in kwargs.get("minus",[]):
        if kwargs.get("method",lambda i: True)(i) == True:
          y.append(i)
  return y
  """
  assert oset([3,2,3,3,2]) == [3, 2]
  assert oset([1,2,1,]) == [1,2]
  assert oset([1,2,1,],method=lambda i: i!=1) == [2]
  assert oset([1,2,1,],method=lambda i: i!=1,minus=[2]) == []
  assert oset([1,2,1,],method=lambda i: i!=1,minus=[3]) == [2]
  """
def osremove(*args,**kwargs):
  os.remove(*args,**kwargs)
def overlay_sound_files(sound_files):
  from pydub import AudioSegment
  sound_file = AudioSegment.from_file(sound_files[0])
  for i in sound_files[1:]:
    new_sound_file = AudioSegment.from_file(i)
    sound_file = sound_file.overlay(new_sound_file)
  sound_file.export(os.path.expanduser("~/Downloads/export.wav"), format='wav')
  return os.path.expanduser("~/Downloads/export.wav")
def pathjoin(*args):
  return os.path.join(*args)
def plusUpdate(x, **kwargs):
  return [[setattr(x,a,getattr(x,a)+b) for a,b in kwargs.items()],x.save(),x][2]
def poll(o, x, step=8, poll_forever=True):
  import polling
  polling.poll(o, step=step, poll_forever=poll_forever)
  x()
  poll(o, x, step=step, poll_forever=poll_forever)
def pool(f, *args, nodes=12, **kwargs):
  # [ERRORFUL] if you do pool(ss.assert_connection_speed, "20MB"), it should have minimum_speed = , otherwise you're saying that "20MB" is the list which you should be pooling.
  results = type("list", (list,), dict(result=lambda self: [keycall("join",self),keycall("result",self)][1]))
  results = results()
  if args and len(args[0]) == 0: return results

  #@results() returns "processing" list. does not fine.
  #@unless i make results keycall join.
  #results = []
  from inspect import getfullargspec
  fullargspec = getfullargspec(f)
  """
  defaults_len = tryreturn(len, fullargspec.defaults)
  accountable_args = listminus(fullargspec.args, (["self"] + list(kwargs)), minus_once = True)
  accountable_args_len = len(accountable_args) - defaults_len
  if accountable_args_len == 0:
    accountable_args_len = accountable_args_len - len(args)
  """
  argcount = f.__code__.co_argcount
  if "self" in fullargspec.args:
    argcount = argcount - 1
  accountable_args_len = argcount -  (len(kwargs))
  # [TESTING] magentaprint(accountable_args_len)

  zilleum = 0
  while True:
    print(keycall("result",results))
    print(accountable_args_len)
    if keycall("result",results).count("processing") < nodes:
      if accountable_args_len != 0:
        #@ruined the args from before calling pool. results.append(process(f,*[a.pop(0) for a in args], **kwargs))
        results.append(process(f,*[a[zilleum] for a in args], **kwargs))
        zilleum+=1
      elif accountable_args_len == 0:
        results.append(process(f, **kwargs))
        zilleum+=1 # umm... this is the counter for the num times def r()'s r runs, which must equal args[0]'s len which is ie, lrange(2), so thats how many times you want function r with 0 arguments to run which is a list of a range of 2 which is twice
        #def hi():
        #@works. hi(**{})
    else:
      time.sleep(0.0001)
    #if len(args[0]) == 0:
    print('args', args)
    print('zilleum', zilleum)
    if not args:
      r = results[0]
      r.join_saved = r.join
      r.result_saved = r.result
      def result(self):
        self.join()
        return self.result_saved()
      is_running = lambda self: self.isAlive()
      bind3(r, result)
      bind3(r, is_running)
      return r
    elif zilleum == len(args[0]):
      # halts for say, args[0] is 11, nodes is 2.
      return results
    assert 1 == len(set(list(map(len, args))))
    # copyright 2021 Adam
def popen(cmd):
  return Popen(cmd.split(' '),shell=False,stdin=None, stdout=None, stderr=None, close_fds=True)
def popen_two(cmd):
  return Popen(cmd.split(" "),shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)
def popwhere(key, keyequals, dictlist):
  [  setitem(g(),"indexes",[])  ,  [g()["indexes"].append(idx)if(keyequals==  (getattr(i,key) if("~~~"!=getattr(i,key,"~~~")) else(i.get(key))  )) else(None)    for idx, i in enum(dictlist)]  ]
  assert len(g()["indexes"]) == 1
  dictlist.pop(g()["indexes"].pop())
  return dictlist
  """
  class Test():
    def __init__(self):
      self.a = "b"
      self.c = "d"
  class Test2():
    def __init__(self):
      self.a = "c"
      self.c = "b"
  dictlist = [Test(),Test2()]
  popwhere("a","b",dictlist)

  class Test():
    def __init__(self):
      self.a = "b"
      self.c = "d"
  class Test2():
    def __init__(self):
      self.a = "b"
      self.c = "b"
  dictlist = [Test(),Test2()]
  try:popwhere("a","b",dictlist)
  except:print("expected error")
  """
def process(func, *args, start_process=1, **kwargs):
  import multiprocessing
  process_id = str(generate_one_random_number(20))
  while process_id in globals():
    process_id = str(generate_one_random_number(20))
  globals()[process_id] = "processing"
  def new_func(func, *args, **kwargs):
    globals()[process_id] = func(*args,**kwargs)
  def strand(func, *args, start_process=1, **kwargs):
    from threading import Thread
    t = Thread(target=func, args=args, kwargs=kwargs)
    t.start()if(start_process==1)else(1)
    return t
  x = strand(new_func, *tuple([func] + list(args)), start_process=start_process, **kwargs)
  x.globals = globals
  x.process_id = process_id
  def result(self):
    return self.globals()[self.process_id]
  bind3(x, result)
  def tmp(self):
    while self.is_alive() == True:
      time.sleep(1)
    return self.globals()[self.process_id]
  bind3(x, tmp)
  return x
def process_(func, *args, start_process=1, **kwargs):
  import multiprocessing
  p = multiprocessing.Process(target=func,*args,**kwargs)
  if(1==start_process):p.start()
  return p
def productcsv(sku_image_dict=None,shop=None,images=None,options=None,variants=None,title=None,product_type=None,tags=None,description=None,):
  {'Body (HTML)': 'Cute but funny',
   'Handle': 'feel-the-force-decor',
   'Image Alt Text': '',
   'Image Position': '1',
   'Image Src': '',
   'Option1 Name': 'Color',
   'Option1 Value': 'Black',
   'Option2 Name': '',
   'Option2 Value': '',
   'Option3 Name': '',
   'Option3 Value': '',
   'Tags': '1, test',
   'Title': 'Feel The Force Decor',
   'Type': 'test',
   'Variant Compare At Price': '14.95',
   'Variant Grams': '0',
   'Variant Image': '',
   'Variant Inventory Qty': '1494',
   'Variant Price': '9.95',
   'Variant SKU': "['sku-1-193']",
   'Vendor': 'Epic Life Shop'}


  {
   'Gift Card': 'false', #
   'Google Shopping / AdWords Grouping': '', #
   'Google Shopping / AdWords Labels': '', #
   'Google Shopping / Age Group': '', #
   'Google Shopping / Condition': '', #
   'Google Shopping / Custom Label 0': '', #
   'Google Shopping / Custom Label 1': '', #
   'Google Shopping / Custom Label 2': '', #
   'Google Shopping / Custom Label 3': '', #
   'Google Shopping / Custom Label 4': '', #
   'Google Shopping / Custom Product': '', #
   'Google Shopping / Gender': '', #
   'Google Shopping / Google Product Category': '', #
   'Google Shopping / MPN': '', #
   'Published': 'true', #
   'SEO Description': '', #
   'SEO Title': '', #
   'Variant Barcode': '', #
   'Variant Fulfillment Service': 'manual', #
   'Variant Inventory Policy': 'deny', #
   'Variant Inventory Tracker': 'shopify', #
   'Variant Requires Shipping': 'true', #
   'Variant Tax Code': '', #
   'Variant Taxable': 'true', #
   'Variant Weight Unit': 'kg', # 
   }


  """Handle               Option1 Value   Option2 Value   Option3 Value Variant SKU Variant Grams Variant Inventory Tracker Variant Inventory Qty Variant Inventory Policy  Variant Fulfillment Service Variant Price Variant Compare At Price  Variant Requires Shipping Variant Taxable   Image Src Image Position 

  Handle  Title Body (HTML) Vendor  Type  Tags  Published Option1 Name    Option2 Name    Option3 Name                          Image Src                                     Variant Image"""

  headers = \
  ['Handle',
   'Title',
   'Body (HTML)',
   'Vendor',
   'Type',
   'Tags',
   'Published',
   'Option1 Name',
   'Option1 Value',
   'Option2 Name',
   'Option2 Value',
   'Option3 Name',
   'Option3 Value',
   'Variant SKU',
   'Variant Grams',
   'Variant Inventory Tracker',
   'Variant Inventory Qty',
   'Variant Inventory Policy',
   'Variant Fulfillment Service',
   'Variant Price',
   'Variant Compare At Price',
   'Variant Requires Shipping',
   'Variant Taxable',
   'Variant Barcode',
   'Image Src',
   'Image Position',
   'Image Alt Text',
   'Gift Card',
   'SEO Title',
   'SEO Description',
   'Google Shopping / Google Product Category',
   'Google Shopping / Gender',
   'Google Shopping / Age Group',
   'Google Shopping / MPN',
   'Google Shopping / AdWords Grouping',
   'Google Shopping / AdWords Labels',
   'Google Shopping / Condition',
   'Google Shopping / Custom Product',
   'Google Shopping / Custom Label 0',
   'Google Shopping / Custom Label 1',
   'Google Shopping / Custom Label 2',
   'Google Shopping / Custom Label 3',
   'Google Shopping / Custom Label 4',
   'Variant Image',
   'Variant Weight Unit',
   'Variant Tax Code']

  x = dictfromkeys(headers, default_value = "")

  x.update({"Option1 Name": getitem(key("name",options), 0, ""), "Option2 Name": getitem(key("name",options), 1, ""), "Option3 Name": getitem(key("name",options), 2, ""), "Title": title, "Body (HTML)": description, "Vendor": "", "Type": product_type, "Tags":"", "Published":"true", "Image Src":images[0]["src"], "Gift Card": "false", "Variant Image": images[0]["src"]})
  image_position = 0
  variants_ = []
  for idx, variant in enumerate(variants):
    variant_ = dictfromkeys(headers, default_value="")
    if idx==0: variant_.update(x)
    variant_["Handle"] = "".join(re.findall(r"[0-9a-zA-Z ]",title)).lower().replace(" ","-").replace("--","-").replace("--","-")
    variant_["Option1 Value"] = variant.get("option1", "")
    variant_["Option2 Value"] = variant.get("option2", "")
    variant_["Option3 Value"] = variant.get("option3", "")
    variant_["Variant SKU"] = variant.get("sku", "")
    variant_["Variant Grams"] = variant.get("weight", "")*100
    variant_["Variant Weight Unit"] = "kg"
    variant_["Variant Inventory Tracker"] = variant["inventory_management"]
    variant_["Variant Inventory Qty"] = variant["inventory_quantity"]
    variant_["Variant Inventory Policy"] = variant["inventory_policy"]
    variant_["Variant Fulfillment Service"] = "manual"
    variant_["Variant Price"] = variant["price"]
    variant_["Variant Compare At Price"] = variant["compare_at_price"]
    variant_["Variant Requires Shipping"] = "true"
    variant_["Variant Taxable"] = "true"
    variant_["Image Src"] = images[ sku_image_dict[variant.get("sku")] ]["src"] if sku_image_dict!={} else images[0]["src"]
    image_position += 1
    variant_["Image Position"] = image_position
    variant_["Variant Image"] = images[ sku_image_dict[variant.get("sku")] ]["src"] if sku_image_dict!={} else ""
    variants_.append(variant_)

  if len(images) > len(variants_):
    for idx, image in enumerate(images[ len(variants_): ]):
      variant_ = dictfromkeys(headers, default_value="")
      variant_["Handle"] = "".join(re.findall(r"[0-9a-zA-Z ]",title)).lower().replace(" ","-").replace("--","-").replace("--","-")
      variant_["Image Src"] = image["src"]
      image_position += 1
      variant_["Image Position"] = image_position
      variants_.append(variant_)




  fn = homepath("~/tavern/tavern/bag/products_%s.csv" % (generate_one_random_number(10)))
  CSV().DictWriteWithHeaders(fn, variants_, headers = headers)
def productgost(x):
  GhostProduct().productgost(x)
def random_dot_float():
  return random.random()
def randomised(x):
  random.shuffle(x)
  return x
def rangelen(x):
  return range(len(x))
def raw_input(x=None):
  return eval(input(""))if(None==x)else(eval(input(x)))
def re_findall_overlaps(regex_string, x):
  groups_regex = '(?=(' + regex_string + '))'
  print("groups regex: %s" % groups_regex)
  matches = re.finditer(groups_regex,x)
  results = [match.group(1) for match in matches]
  print("%s matches" % len(results))
  return results
def re_found_function(x,r,method):
  if findall(x,r):
    return method(x)
  else:
    return x
def re_spaces(x):
  return re_substitute(x,["\s+"," "]).strip()
def re_substitute(x,y,*y_is_a_two_list,**kwargs):
  return re.sub(y[0],y[1],x,**kwargs)
  """
  re_substitute("AbAb",["^Ab","c"],flags=re.M)
  """
def re_substitute_function(x,r,method):
  found = findall(x,r)
  if len(found) == 0: print("No found matches")
  print(x)
  random_strings = []
  multiplier = 10000
  for i in lrange(len(found)):
    random_strings.append("<<<<<%s>>>>>"%(random.choice(string.ascii_letters)*multiplier))
    multiplier = multiplier * 10
  for i,j in zip(found,random_strings): x = x.replace(i,j)
  y = lmap(lambda i:str(method(i)),found)
  for i,j in tcer(list(zip(random_strings,y))): x = x.replace(i,j)
  print(x)
  return x
def readministrate():
  import getpass
  os.system("sudo -passwd admin")
  os.system("sudo dscl . -append /Groups/admin GroupMembership %s"%(getpass.getuser()))
def rfloat(r1 = 0.2, r2 = 0.7):
  return random.uniform(r1, r2)
def rm(address):
  subprocess.getoutput("""rm -rf "%s" """%address)
def safarijs(x):
  blueprint("Safari -> Advanced -> Show develop menu ; Develop -> Allow JavaScript from Apple Events")
  x = 'tell application "Safari" to do JavaScript "%s" in current tab of window 1'%x
  fn = ".%s.scpt" % str(generate_one_random_number(10))
  blueprint(fn)
  open(fn, "w").write(x)
  r = subprocess.getoutput("osascript %s"%fn)
  os.remove(fn)
  return r
  """
  x = "window.location.href = 'https://google.com'"
  safarijs(x)
  """
def save_default_aceintheholedata():
  exec('def x(y,    ):\n  from decimal import Decimal\n  import datetime\n  from dateutil.tz import tzoffset\n  globals().update(locals())\n  fields = key("name",  y._meta.fields)\n  blueprint("Save(%s,   "%(type(y).__name__),   end="")\n  for i in fields:\n    z = getattr(y,  i)\n    r = None\n    import datetime\n    if type(z) == str:\n      r = \'%s = """%s""",   \'%(i,    z)\n    elif type(z) == datetime.datetime:\n      r = \'%s = datetime.datetime(%s,   %s,   %s,   %s,   %s,   %s,   %s),   \'%(i,   z.year,   z.month,   z.day,   z.hour,   z.minute,   z.second,   z.microsecond)\n    elif type(z) == datetime.date:\n      r = \'%s = datetime.date(%s,   %s,   %s),   \'%(i,   z.year,   z.month,   z.day,   )\n    else:\n      r = "%s = %s,   "%(i,   z)\n    blueprint(r.replace("\\n",    "\\\\n"),  end="")\n  blueprint(")",  end="")\n  blueprint("\\n")',globals())
  import datetime
  from decimal import Decimal
  Save(AceInTheHole,   id = 408,   account = """Chase""",   date = datetime.datetime(2019,   4,   29),   amount = 10.0,   type = """BUSINESS_PAYMENT_GATEWAY_DEPOSITS""",   tag = """STRIPE""",   description = """STRIPE""",   )
  Save(AceInTheHoleType,   id = 18,   name = """BUSINESS_OTHER_CONTRACT_LABOR""",   )
  Save(AceInTheHoleType,   id = 19,   name = """BUSINESS_OTHER_HOSTING""",   )
  Save(AceInTheHoleType,   id = 20,   name = """BUSINESS_OTHER_SUBSCRIPTIONS""",   )
  Save(AceInTheHoleType,   id = 14,   name = """BUSINESS_PAYMENT_GATEWAY_DEPOSITS""",   )
  Save(AceInTheHoleType,   id = 15,   name = """BUSINESS_PAYMENT_GATEWAY_WITHDRAWALS""",   )
  Save(AceInTheHoleType,   id = 17,   name = """BUSINESS_PURCHASING_ADS""",   )
  Save(AceInTheHoleType,   id = 16,   name = """BUSINESS_PURCHASING_PRODUCTS""",   )
  Save(AceInTheHoleType,   id = 22,   name = """PERSONAL_FOOD""",   )
  Save(AceInTheHoleType,   id = 21,   name = """PERSONAL_NOT_FOOD""",   )
  Save(AceInTheHoleTypeTag,   id = 12,   type = """BUSINESS_PURCHASING_PRODUCTS""",   tag = """Ali""",   sign = """negative""",   )
  Save(AceInTheHoleTypeTag,   id = 13,   type = """BUSINESS_PAYMENT_GATEWAY_DEPOSITS""",   tag = """Stripe Deposit""",   sign = """positive""",   )
  Save(AceInTheHoleTypeTag,   id = 29,   type = """PERSONAL_NOT_FOOD""",   tag = """METROCARD""",   sign = """negative""",   )
  Save(AceInTheHoleTypeTag,   id = 30,   type = """PERSONAL_NOT_FOOD""",   tag = """ATM FEE""",   sign = """negative""",   )
def savepickles(*args,**kws):
  pickle.dump([i for i in args if type(i)!=str][0],open([i for i in args if type(i)==str][0],'wb'))
  ifdo(lambda:kws.get('copypickles'),lambda:savepickles(args[0],kws['copypickles']))
  return args[0]
def saveobj(x):
  import _pickle
  import pickle
  import dill
  return dill.dumps(x)
def sch(x):
  from spellchecker import SpellChecker as sch
  sch = sch()

  a = list(set(re.findall("[\w']+",x)))
  b = pool(lambda i: sch.correction(i), a).result()
  e = dict(zip(a,b))
  c = [i for i in a if i not in b]
  distinct_print(c)
  for i in c:
    while True:
      print("+1",i)
      d=tryreturn(lambda:next(re.finditer("""[^\w'](%s)(?:[^\w']|$)"""%(i),x)))
      if d:
        blueprint(x)
        x = "".join([x[:d.start()],x[d.start():d.start()+1],e[i],(x[d.end()-1:d.end()])if(x[d.end()-1:d.end()]==" ")else(" "),x[d.end():]])
        greenprint(x)
      else:
        break
  x = x.upper()
  return x
  """
  x = '''hello,
  ths is col
  hllo.
  bye\tyes4 123
  '''
  """
def screenshot(address=None):
  if address == None:
    os.makedirs(homepath("~/tavern/tavern/soda/dls"), exist_ok = True)
    address = homepath("~/tavern/tavern/soda/dls/%s.png"%(random.randrange(9999999999999)))
    magentaprint("generated address: %s" % address)
  greenprint("saving to address: %s" % address)
  os.system("""screencapture -x "{}" """.format(address))
  return address
def sedremoveline(file,line_numbers):
  os.system("""sed -i "" -e "%sd" '%s'"""%((",".join(lmap(str,line_numbers))),file))
  """
  os.system('''echo -e "line1\nline2\nline3\nx" > infile''')
  sedremoveline("infile",[1,2])
  assert open("infile").read() == 'line3\nx\n'
  rm("infile")
  """
def setadd(x,y):
  if y not in x:
    x.add(y)
  return x
def setattrs(x, *args, **kwargs):
  from types import MethodType,ModuleType,FunctionType
  for a,b in kwargs.items():
    setattr(x,a,b)
  for a,b in zip(args[0::2],args[1::2]):
    if type(b) == FunctionType or type(b) == MethodType:
      b = tryreturn(lambda: b())
    setattr(x,a,b)
  """
  a = AD()
  setattrs(a,"x",2,"y",3,"z",4)
  """
def setfrom(x, *args):
  return [i(x) for i in args]
  """
  setfrom(1, lambda i: i, lambda i: i)
  """
def setitem(x, k, v):
  x[k] = v
def setitems(x,*args):
  for i,j in zip(args[0::2],args[1::2]):
    x[i] = j
def show_in_list(a,b):
  a = copy.deepcopy(a)
  b = copy.deepcopy(b)
  x = []
  for i in a:
    if i in b:
      x.append(i)
      b.__delitem__(b.index(i))
  return x
  """
  assert show_in_list([1,2,3,4],[1,2]) == [1,2]
  assert show_in_list([10,10],[10]) == [10]
  assert show_in_list([10,10],[10,11]) == [10]
  """
def show_overhead(a, b):
  # assert len(oset(a)) == len(a)
  # assert len(oset(b)) == len(b)
  a = copy.deepcopy(a)
  b = copy.deepcopy(b)
  x = []
  for i in a:
    if i not in b:
      x.append(i)
    elif i in b:
      b.__delitem__(b.index(i))
  return x
  """
  show_overhead([1,2,3,4],[1,2])
  show_overhead([10,10],[10])
  """
def shuffled(x):
  if type(x) is str:
    x = list(x)
    random.shuffle(x)
    return x
  else:
    x = list(x)
    random.shuffle(x)
    return x
  return x
def shutil_move(a, b):
  import shutil
  shutil.move(a, b)
def similar(a, b):
  from difflib import SequenceMatcher    
  return SequenceMatcher(None, a, b).ratio()
def slank(key,dict_):
  return dict_.pop(key)
def slow_url(x):
  return x.split("?")[0]
def sorted_list_matching(x,y):
  z = lmap(lambda i:None,x)
  for i in x:
    index = y.index(i)
    z[index] = i
  return z
  """
  a = [2,1,3]
  b = [1,2,3]
  sorted_list_matching(a,b)
  """
def sorted_set(x):
  return list(sorted(list(set(x))))
def soupy(soup,x=None,y=None,z=None):
  import bs4
  if type(soup) != bs4.BeautifulSoup: soup = BeautifulSoup(soup)
  if x==None: return soup
  return(soup.findAll(x)if(None==y==z)else(soup.findAll(x,attrs={y:z})))
def sql_get_multiple_primary_keys(x):
  with open(__file__,"r") as f:
    return [i.strip().split("=")[0].strip() for i in re.findall(r"(?s)(class %s\(Worksheet\):.*?)class"%x.__name__,f.read())[0].strip().split("\n") if((-1!=i.find("AutoField()"))or(-1!=i.find("unique=True"))or(-1!=i.find("primary_key=True")) )]
def sqltroubleshoot():
  os.system("""rm /usr/local/etc/my.cnf && echo "Removed mysql cnf file." sleep 5 && echo "Stopping mysql." && sleep 5 && brew services stop mysql & sleep 5 && mysqld & sleep 5 && echo "Running py2_file again to set up mysql cnf file." && sleep 5 && cd ~/tavern/tavern/soda && /usr/bin/python -B -c "from py2_file import *; Setter_Upper().m15__17_initiate_install_mysql__and__create_database_soda()" ;""")
def strand(func, *args, **kwargs):
  from threading import Thread
  t = Thread(target=func, args=args, kwargs=kwargs)
  t.start()
  return t
def strands(func, x, c=32, *args, **kwargs):
  for idx, i in enumerate(array_split(x, c)):
    stuff = []
    for j in i:
      stuff.append(strand(func, j, *args, **kwargs))
    for s in stuff:
      s.join()
    print("%s out of %s at %s per done for %s"%(idx, (len(x)/c), c, func.__name__))
def strcls(x,**kwargs):
  return type("a",(str,),kwargs)(x)
  """
  r = intcls("asdf",print = lambda self:print(self))
  r.print()
  """
def sud(dictlist, key):
  if type(dictlist) is str:
    dictlist2 = dictlist
    dictlist = key
    key = dictlist2
  try: return [getattr(i, key) for i in list(dictlist)]
  except: return [i[key] for i in list(dictlist)]
def sudby(x,y):
  return or_list(lambda:[i for i in y if x(i)],lambda:[i for i in y if x(*i)],[])
def sudcall(key, dictlist, *args, **kwargs):
  try: return [getattr(i, key)(*args, **kwargs) for i in list(dictlist)]
  except: return [i[key](*args, **kwargs) for i in list(dictlist)]
def sudsort(key, dictlist, tcer=True):
  import operator
  if type(key) is not list:
    key = [key]
  try: return sorted(list(dictlist), key=operator.itemgetter(*key), reverse=tcer)
  except: return sorted(list(dictlist), key=operator.attrgetter(*key), reverse=tcer)
def sudsort_multi(columns, items, tcer=False):
  from operator import itemgetter, attrgetter
  from functools import cmp_to_key
  comparers = None
  if tryprocess(lambda:items[0].get(columns[0])): comparers = [((itemgetter(col[1:].strip()), -1) if col.startswith('-') else (itemgetter(col.strip()), 1)) for col in columns]
  else: comparers = [((attrgetter(col[1:].strip()), -1) if col.startswith('-') else (attrgetter(col.strip()), 1)) for col in columns]
  def comparer(left, right):
    def cmp(a, b):
      if a == None and b == None: return 0
      if a == None and b != None: return 1        
      if a != None and b == None: return -1
      elif a != None and b != None: return (a > b) - (a < b)
    comparer_iter = ( cmp(fn(left), fn(right)) * mult for fn, mult in comparers)
    return next((result for result in comparer_iter if result), 0)
  return sorted(list(items), key=cmp_to_key(comparer), reverse=tcer)
def swamp(*args):
  a, b = args[0], args[1]
  for x, y in zip(a, b):
    if y() == True:
      return x()
  """
  a, b, c = 1,0,0
  (1)if(a==True)else(2)if(b==True)else(3)if(c==True)else()
  a, b, c = 0,1,0
  (1)if(a==True)else(2)if(b==True)else(3)if(c==True)else()
  a, b, c = 0,0,1
  (1)if(a==True)else(2)if(b==True)else(3)if(c==True)else()
  swamp(lambda: a==True, lambda: b==True, lambda: c==True, lambda: 1, lambda: 2, lambda: 3)
  
  def ard():
    print(d)
  def r():
    a = 1
    b = 0; c= 0; d=5
    swamp(lambda: a==True, lambda: b==True, lambda: c==ard(), lambda: 1, lambda: 2, lambda: 3)
    (1)if(a==True)else(2)if(b==True)else(3)if(c==ard())else()
  """
def sys_exit():
  [exec("import sys",globals()), sys.exit()]
def tcer(x,a=0):
  return reversed(x)if(a==0)else(list(reversed(x)))
def text_to_docx(text, filename):
  from docx import Document
  document = Document()
  paragraph = document.add_paragraph(text)
  from docx.shared import Pt
  style = document.styles["Normal"]; document.styles["Normal"].font.name = "Times New Roman"; document.styles["Normal"].font.size = Pt(4); 
  paragraph.style = document.styles["Normal"]
  document.save(filename)
def text_to_image(text):
  from PIL import Image, ImageDraw, ImageFont

  if text == "":
    text = "\n"
   
  img = Image.new('RGB', (1800, 540), color = (255, 255, 255))
  fnt = ImageFont.truetype("/Library/Fonts/Times New Roman.ttf", 20)
  d = ImageDraw.Draw(img)
  d.text((0,0), text, font=fnt, fill=(0, 0, 0))
  font_size = d.textsize(text, fnt)

  img = Image.new('RGB', font_size, color = (255, 255, 255))
  fnt = ImageFont.truetype("/Library/Fonts/Times New Roman.ttf", 20)
  d = ImageDraw.Draw(img)
  d.text((0,0), text, font=fnt, fill=(0, 0, 0))

  address = get_random_address(homepath("~/tavern/tavern/soda/dls")).png()
  img.save(address)
  impreview(address)
  os.remove(address)
def textplot(L,a,b):
  def divs(x,c):
    return [int(x/c)*i for i in range(c+1)]
  Q=divs(a,b) + [max(L)]
  def slot_file(L,x):
    r = []
    for idx, i in enum(x[:-1]):
      r.append(["%s-%s"%(i,x[idx+1]),len(sorted([a for a in L if a>i and a<=x[idx+1]]))])
    return r
  slot_file(L,Q)
  data= slot_file(L,Q)

  max_value = max(count for _, count in data)
  increment = max_value / 25
  longest_label_length = max(len(label) for label, _ in data)
  O = []
  for label, count in data:
    bar_chunks, remainder = divmod(int(count * 8 / increment), 8)
    bar = '' * bar_chunks
    if remainder > 0:
        bar += chr(ord('') + (8 - remainder))
    bar = bar or  ''
    O.append(bar+ " " + "(%s(%s))"%(str(label.rjust(longest_label_length).strip()),"%sCount"%(str(round(count,4)))) )
  O = ("\n".join(O))
  drkprint(O)
  return O
def timed(r,x):
  m = datetime.now()
  R = process(r)
  while True:
    l = datetime.now()
    if (l-m).seconds >=x and R.is_alive() == True:
      drkprint("timed out at %s seconds, returning None"%(x))
      return None
    elif (l-m).seconds <x and R.is_alive() == False:
      drkprint("timed in at %s seconds, "%(x))
      break
  return R.result()
def timed_input(prompt, x=10):
  import select
  cyanprint(prompt, end="")
  sys.stdout.flush()
  i,o,e = select.select([sys.stdin],[],[],x)
  if (i):
    response = sys.stdin.readline().strip()
    print("You said %s" % response)
    return response
  else:
    print("response [None]")
    return None
def thread(f, x, c=32):
  from multiprocessing.dummy import Pool
  pool = Pool(c)
  payload = pool.map(f, x)
  pool.close()
  pool.join()
  return payload
def time_a_download(method, arg=None):
  import time
  
  current = get_dircount()
  command = None
  if arg:
    command = 'method(%s)'%arg
  else:
    command = 'method()'
  exec(command)
  while get_dircount() == current and '.part' not in get_latest_download():
    time.sleep(0.05)
  time.sleep(5)
  return get_latest_download()
def timeit(func):
  def wrapper(*arg, **kw):
    t1 = time.time()
    res = func(*arg, **kw)
    t2 = time.time()
    print("timeit: %s, %s"%((t2 - t1), func.__name__))
    return res
  return wrapper
def timedretry(x,y):
  z = multiprocessing_process(x)
  time.sleep(y)
  if z.is_alive():
    z.terminate()
    return timedretry(x,y)
  else:
    return
def timedtask(func):
  def wrapper(*arg, **kw):
    t1 = time.time()
    start_datetime = datetime.now()



    new = Timedtask()
    new.function_name = func.__name__


    existants = Filter(Timedtask,function_name=new.function_name)
    zellums = key("elapsed",existants)
    stis = (sum(zellums)/len(zellums))
    redprint("stis")
    
    roundulo = int(stis/100)

    def sleeperman():
      for sleeptime in range(roundulo):
        lox = ""*i
        sys.stdout.write(lox)
        sys.stdout.flush()
        time.sleep(sleeptime)
    import multiprocessing
    p = multiprocessing.Process(target=sleeperman)
    p.start()
    res = pool(func, *args, **kw)
    p.terminate()
    sys.stdout.write((""*10)+" %100")

    res = res[0]
    t2 = time.time()
    end_datetime = datetime.now()
    elapsed_time = (end_datetime - start_datetime).seconds
    print("elapsed: time: %s" % elapsed_time)
    print("timeit: %s, %s"%((t2 - t1), func.__name__))

    new.start = start_datetime
    new.end = end_datetime
    new.elapsed_time = elapsed_time
    new.my_time_elapsed = (1.1574074074074073e-05) * elapsed_time
    new.my_time_start = Date().myDatetimenow(start_datetime)
    new.my_time_end = Date().myDatetimenow(end_datetime)
    new.save()
    distinct_print(ordered_json_dumps(new.__dict__))
    return res
  return wrapper
def timer(t, func, *args, **kwargs):
  t = Timer(t, func, args=args, kwargs=kwargs)
  t.start()
  return t
def timestamp(x,forward=True):
  if forward == True:
    timestamp = datetime.timestamp(x)
    return timestamp
  elif forward == False:
    datetime_ = datetime.fromtimestamp(x)
    return datetime_
def tinyurl(url):
  return requests.get("http://tinyurl.com/api-create.php?url=%s"%(url)).text
def tp(func, *args, ep=0, error = None, **kwargs):
  import multiprocessing
  t = multiprocessing.Process(target=func, args=args, kwargs=kwargs)
  #t = multiprocessing.Process(target=func)#, args=args, kwargs=kwargs)
  try:
    t.run()
    return 1
  except Exception as e:
    #OSA.notify("%s, %s, %s" %  (str(func), str(args), str(kwargs)))
    #OSA.notify("tryprocess: " + str(e))
    #pyperclip.copy(str(e))
    OSA.log(str(or_list(error,e)))if(1==ep or error)else(1)
    return 0
def tr(func, *args, ep=0, error = None, **kwargs):
  """ ep - errorprint , error - supply own error """
  try:  
    return func(*args, **kwargs)
  except Exception as e:
    ifdo(lambda:(1==ep) or error,
          lambda:(print("Got Exception"),input(str(error if error !=None else e))))
    return 0
  """
  print(tr(lambda:0/0)==0)
  print(tr(lambda:1/1/)==1)
  """
def transfer_bash():
  os.system("""rm ~/tavern/tavern/soda/bash_profile; cp -r ~/.bash_profile ~/tavern/tavern/soda/bash_profile""")
def transfer_workflows():
  [os.system("rm -rf /Users/$USER/tavern/tavern/soda/*.workflow"),[os.system("cp -r ~/Library/Services/%s ~/tavern/tavern/soda/%s"%(i,i)) for i in os.listdir(homepath("~/Library/Services")) if i.endswith(".workflow")]]
def transpose(x):
  """
  import numpy as np
  x = np.transpose(x)
  x = [list(i) for i in x]
  return x
  """

  shieldgang=[]
  zilleum=0
  [[1,2,3],[1,2,3]]
  [[1,1,],[2,2],[3,3]]
  # for i in range of len [1,2,3], so 3x, get the nth idx of each poser
  for i in range(len(x[-1])):
    hot = [i[zilleum] for i in x]
    shieldgang.append(hot)
    zilleum = zilleum + 1

  return shieldgang
  """
  assert [[1, 1], [2, 2], [3, 3]] == transpose([[1,2,3],[1,2,3]])
  x = [[1,2],
    [1,2]]
  greenprint(transpose(x))
  """
def trykeycall(key, dictlist, *args, **kwargs):
  try: return [tryprocess(getattr(i, key), *args, **kwargs) for i in list(dictlist)]
  except: return [tryprocess(i[key], *args, **kwargs) for i in list(dictlist)]
def trylmap(f, x, *args, **kwargs):
  Q = []
  for i in x:
    Z = tryprocess(f, i, *args, **kwargs)
    Q.append(Z)
  return Q
def tryprocess(func, *args, ep=0, error = None, **kwargs):
  import multiprocessing
  t = multiprocessing.Process(target=func, args=args, kwargs=kwargs)
  #t = multiprocessing.Process(target=func)#, args=args, kwargs=kwargs)
  try:
    t.run()
    return 1
  except Exception as e:
    #OSA.notify("%s, %s, %s" %  (str(func), str(args), str(kwargs)))
    #OSA.notify("tryprocess: " + str(e))
    #pyperclip.copy(str(e))
    OSA.log(str(or_list(error,e)))if(1==ep or error)else(1)
    return 0
def tryreturn(func, *args, ep=0, error = None, **kwargs):
  """ ep - errorprint , error - supply own error """
  try:  
    return func(*args, **kwargs)
  except Exception as e:
    ifdo(lambda:(1==ep) or error,
          lambda:(print("Got Exception"),input(str(error if error !=None else e))))
    return 0
  """
  print(tryreturn(lambda:0/0)==0)
  print(tryreturn(lambda:1/1/)==1)
  """
def typecls(x,**kwargs):
  return type("a",(int,),kwargs)(x) if type(x)==int else(
         type("a",(str,),kwargs)(x)) if type(x)==str else(
         type("a",(list,),kwargs)(x)) if type(x)==list else(
         type("a",(float,),kwargs)(x)) if type(x)==float else(
         type("a",(Time,),kwargs)(x)) if type(x)==datetime else(
         type("a",(dict,),kwargs)(x)) if type(x)==dict else()
def typed(a={}):
  return type("",(a.get("type",object),),a)
  """
  typed({})()
  """
typed()
def uli(x,y,z=-1):
  return x.split(y,z)
def unpack_archive(address):
  import shutil
  import zipfile
  shutil.unpack_archive(address, "%s.zip"%address)if(os.path.isdir(address))else(zipfile.ZipFile(address,"r").extractall(os.getcwd()))
def update(x,**kwargs):
  lmap(lambda k,v: setitem(x,k,v), list(kwargs.items()))
  return x
  """
  assert update({"a":"b"},e=5) == {'a': 'b', 'e': 5}
  """
def urlopenproduct(product,url):
  [pyperclip.copy(url%(product.handle)), OSA.log("Press OK"), OSA("Google Chrome 70",["ctrl_t","ctrl_l","ctrl_v","return"])]
def valuelist(x):
  return {a:b for a,b in x}
  """
  valuelist([(1,2), (2,3), (3,4)])
  """
def varsave(x):
  'def varsave(x):\n  image_ids = key("image_id", x.variants)\n  first_save = apilimitcall(x.save)\n  assert first_save == True\n  image_ids_after_save = key("image_id", x.variants)\n  if image_ids_after_save != image_ids:\n    for a, b in zip(x.variants, image_ids):\n      a.image_id = b\n    pool(lambda i: apilimitcall(i.save), x.variants, nodes=4).result()\n    if len(x.variants) > 50:\n      time.sleep(0.2)\n  return x'
  image_ids = key("image_id", x.variants)
  first_save = apilimitcall(x.save)
  assert first_save == True
  image_ids_after_save = key("image_id", x.variants)
  if image_ids_after_save != image_ids:
    for a, b in zip(x.variants, image_ids):
      a.image_id = b
    image_ids_x = oset(sud("image_id",x.variants))
    new = dictfromkeys(image_ids_x,[])
    for a, b in new.items():
      new[a] = sud("id",filter(x.variants,image_id=a))
    for a, b in new.items():
      y = filter(x.images,id=a)[0]
      y.variant_ids = new[a]
    x.save()
    # pool(lambda i: apilimitcall(i.save), x.variants, nodes=6).result()
    # if len(x.variants) > 50:
    #   time.sleep(0.2)
  return x
def versioncheck(x,z=None):
  exec("import selenium; bprint(selenium.__version__); y = selenium.__version__",globals())
  if z:os.system("pip install %s==%s"%(x,z))
  return y
def viden(x,*args):
  print(args)
  for i,j in zipeven(args[0::2],args[1::2],None):
    if j == None:
      x = x.split(i)
    else:
      x = x.split(i)[j]
  return x
  """
  viden("asdfa","a",1)
  """
def wall(i):
  return ceil(i)if((i)%1>=0.5)else(floor(i))
def word_multiply(l1,l2):
  x = []
  for i in l1:
    for j in l2:
      x.append([i,j])
      x.append([j,i])
  return x
def wordcount(x):
  apostrophes = x.count("'")
  words = len(x.split(" "))
  count = apostrophes + words
  return count
def writew(x,y):
  open(x,"w").write(y)
  return x
def writewb(x,y):
  open(x,"wb").write(y)
  return x
def write_xlsx_cell(cell,x,wb=None,save=False):
  ws = None
  if globe("workbook"):
    wb = globe("workbook")
    ws = wb.worksheets[0]
  else:
    import openpyxl
    wb = ifelseget(lambda:os.path.exists(wb),lambda:openpyxl.load_workbook(wb),lambda:openpyxl.Workbook())
    ws = wb.worksheets[0]
    globalise(wb,"workbook")
  ws[cell].value = x
  if save:
    wb.save("out.xlsx")
  return wb
def xir(x,**kwargs):
  [setattr(x,i,j) for i,j in kwargs.items()]
  return x
def xplist(x):
  r = '\n  <?xml version="1.0" encoding="UTF-8"?>\n  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n  <plist version="1.0">\n  <dict>\n      <key>Label</key>\n      <string>{}</string>\n      <key>ProgramArguments</key>\n      <array>\n      <string>/Users/%s/tavern/bin/python3.5</string>\n      <string>-c</string>\n      <string>{}</string>\n      </array>\n      <key>UserName</key>\n      <string>%s</string>\n      <key>StandardOutPath</key>\n      <string>{}</string>\n      <key>StandardErrorPath</key>\n      <string>{}</string>\n      <key>KeepAlive</key>\n      <true/>\n  </dict>\n  </plist>\n  '%(getuser(),getuser())
  title = "%s"%([exec("import nltk",globals()),random.sample(random.sample(list(nltk.wordnet.wordnet.all_synsets(nltk.wordnet.wordnet.NOUN)),1)[0].lemmas(),1)[0].name()][1])
  os.makedirs(homepath("~/tavern/tavern/soda/plists"),exist_ok=True)
  save_path = homepath("~/tavern/tavern/soda/plists/%s.plist"%(title))
  y = 'import os; os.chdir(os.path.expanduser("~/tavern/tavern")); from soda.can import *; %s'%(x)
  x = r.format(save_path.split("/")[-1].split(".")[0],y,save_path+".out",save_path+".err").strip().replace("\n  ", "\n")
  open(save_path, "w").write(x)
  return x
def zeroith():
  return(str)
def zipUtil(address,reverse=not True):
  # developer note: if you're interested in command line `zip` for windows, use : https://sourceforge.net/projects/gnuwin32/files/zip/3.0/ ((link from: https://www.tecmint.com/create-password-protected-zip-file-in-linux/)) ... add it to C:\Windows\System32
  if reverse!=True:
    # - zip -  a file
    redprint("    # - zip -  a file   ---- ")
    # set original path
    redprint("    # set original path   ---- ")
    setitem(globals(),"cwd",os.getcwd())
    # normalize address
    redprint("    # normalize address   ---- ")
    setitem(globals(),"address",address_normalize(address))

    # chdir from homepath to /Users, ~/picture.png to homepath, tryprocess from picture.png to `""`
    redprint("    # chdir from homepath to /Users, ~/picture.png to homepath, tryprocess from picture.png to `""`   ---- ")
    tryprocess(os.chdir, "/".join(globals()["address"].split("/")[:-1]))

    # set address to ./`address`
    redprint("    # set address to ./`address`   ---- ")
    setitem(globals(),"address",globals()["address"]if(-1==globals()["address"].find("/"))else(globals()["address"].split("/")[-1]))


    # remove the directed address
    redprint("    # remove the directed address   ---- ")
    subprocess.getoutput(""" rm -rf "%s.zip" """%globals()["address"])
    # waitfor directed address gone
    redprint("    # waitfor directed address gone   ---- ")
    while(1==os.path.exists("%s.zip"%globals()["address"])): time.sleep(0.1)



    # zip ~/tavern/tavern/drawings to ./drawings.zip
    redprint("    # zip ~/tavern/tavern/drawings to ./drawings.zip   ---- ")
    subprocess.getoutput("""zip -r "%s.zip" "%s" """%(globals()["address"],globals()["address"]))
    # waitfor gone not directed address
    redprint("    # waitfor gone not directed address   ---- ")
    while(0==os.path.exists("%s.zip"%globals()["address"])): time.sleep(0.1)

    # revert to original path
    redprint("    # revert to original path   ---- ")
    os.chdir(globals()["cwd"])
    redprint(address+".zip",)
    return address+".zip"


  elif reverse==True:
    # - unzip - a file
    redprint("    # - unzip - a file   ---- ")
    # remove&waitfor directed folder address
    redprint("    # remove&waitfor directed folder address   ---- ")
    subprocess.getoutput("""rm -rf "%s" """%(address[:-4]))
    while(1==os.path.exists(address[:-4])): time.sleep(0.1)

    # unzip&waitfor directed folder address
    redprint("    # unzip&waitfor directed folder address   ---- ")
    if "/" in address:
      direc = "/".join(address.split("/")[:-1])
      os.chdir(direc)
    subprocess.getoutput("""unzip "%s" """%(address))
    #while(0==os.path.exists(address[:-4])): time.sleep(0.1)

    # remove&waitfor original zip address
    redprint("    # remove&waitfor original zip address   ---- ")
    subprocess.getoutput("""rm -rf "%s" """%(address))
    #while(1==os.path.exists(address)): time.sleep(0.1)
    redprint(address[:-4],)
    return address[:-4]
def zipeven(x,y,z):
  x, y = list(x), list(y)
  if len(x) != len(y):
    if len(y) > len(x):
      x.append(z)
    elif len(x) > len(y):
      y.append(z)
  return zip(x,y)
  """
  assert list(zipeven([1,2,3],[1,2],None)) == [(1, 1), (2, 2), (3, None)]
  assert list(zipeven([1,2],[1,2,3],None)) == [(1, 1), (2, 2), (None, 3)]
  """
def zki(x,y,z):
  if x():
    return lmap(y,z)
  else:
    return z
  """
  zki(lambda: 1==1, lambda i: i+1, [1,2,3])
  zki(lambda: 1==2, lambda i: i+1, [1,2,3])
  """
def zz(x):
  #print("sleeping %s"%x); time.sleep(x)
  time.sleep(x)
