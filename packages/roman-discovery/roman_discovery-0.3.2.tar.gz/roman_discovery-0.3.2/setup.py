# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['roman_discovery', 'tests']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'roman-discovery',
    'version': '0.3.2',
    'description': 'Discover packages and classes in a python project.',
    'long_description': '# Roman Discovery\n\n## Micro-framework initialization is a mess\n\nMicro-framework-based projects are clean while they\'re small. Every micro-framework codebase I\'ve seen suffer from the same problem: a mess in the project initialization module. Sooner or later, your entry point package becomes a soup of ad-hoc environment reads, imports-within-functions, and plug-in initializations.\n\nThe infamous `create_app()` is a boiling broth where architectural rules, dependencies, and common sense don\'t exist.  The core of The Application Factory Pattern, proposed, for example, in the [official Flask documentation](https://flask.palletsprojects.com/en/2.0.x/patterns/appfactories/), and the [Flask Mega-Tutorial](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure), legitimize this pattern.\n\nIt would be OK to keep that ugly, primordial mess hidden behind a layer of abstraction, but the primitive nature of `create_app()` leaves no place for the [open-closed principle](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html). We need to get back to this module every time we add a new plug-in, a new blueprint, or a new package.\n\n## Discovery to the rescue\n\nWhen it comes to taming the chaos, opinionated structure and automated discovery can help.\n\n- You describe your application structure, outlining where you keep models, blueprints, controllers, etc.\n- You define auto-discovery rules: what your initialization code does when it finds an object of a specific type.\n- You let roman-discovery do the rest.\n\nIt\'s specifically helpful for frameworks that define resources on the fly with decorators and expect you to import all necessary modules. For example, it can be helpful for Flask to load all your blueprints, initialize extensions, and import SQLAlchemy models.\n\n[Visitor pattern](https://refactoring.guru/design-patterns/visitor) is the best name for the approach you like finding patterns in implementation details.\n\n\n## Install\n\n```shell\npip install roman-discovery\n```\n\n## Glossary\n\nI find it helpful to add some semantic colors to the packages and modules of the app. For this, I introduce the terms "domain package" and "module role."\n\n**Domain package** -- one of the multiple top-level packages of the application that contains the business logic. Adepts of domain-driven design would define domain packages as containers to encapsulate [bounded contexts](https://martinfowler.com/bliki/BoundedContext.html).\n\n**Module Role** -- a group of modules or packages (directories with `__init__.py` files) used for the same purpose. I prefer express roles with module prefixes or second-level packages. For example, files `models_users.py` and `models_groups.py` can have the "Models" role and keep your model definitions, and files `controllers_users.py` and `controller_groups.py` can have the "Controllers" role and keep the code for your controllers.\n\n## Usage with Flask\n\nUsing within the opinionated Flask structure was the initial purpose of the package. Use `roman_discovery.discover()` with\n`roman_discovery.flask.get_flask_rules()`.\n\nThe function expects the following project structure.\n\n```\nmyproject\n\n  app.py\n  config.py\n  services.py\n\n  # Simple flat structure with one module\n  # per role in a domain package.\n  foo/\n    controllers.py\n    models.py\n    cli.py\n\n\n  # Flat structure with multiple modules per\n  # role in a domain package. Modules of the same\n  # role share the same prefix\n  bar/\n    controllers_api.py\n    controllers_admin.py\n    models_users.py\n    models_projects.py\n    cli_users.py\n    cli_projects.py\n\n  # Nested structure with one flat package per role\n  baz/\n    controllers/\n      api.py\n      admin.py\n    models/\n      users.py\n      projects.py\n    cli/\n      users.py\n      projects.py\n```\n\nWith this structure, it will do the following.\n\n- Scan controllers.py, controllers_*.py and controllers/ to find blueprints and attach the blueprints to the flask application.\n- Import all files in models.py models_*.py and models/ to help flask-migrate find all the SQLAlchemy models to create migrations.\n- Scan cli.py, cli_*.py and cli/ to find flask.cli.AppGroup instances and attach them to Flask\'s CLI.\n- Scan top-level services.py, find all the instances that have `init_app()` methods, and call `obj.init_app(app=flask_app)` for each of them.\n\nAn example of your top-level app.py\n\n```python\n# file: myproject/app.py\nfrom flask import Flask\nfrom roman_discovery import discover\nfrom roman_discovery.flask import get_flask_rules\n\n\ndef app() -> Flask:\n    flask_app = Flask(__name__, instance_relative_config=True)\n    flask_app.config.from_object("myproject.config")\n    flask_rules = get_flask_rules("myproject", flask_app)\n    discover("myproject", flask_rules)\n    return flask_app\n```\n\nAn example of your top-level services.py\n\n```python\n# file: myproject/services.py\n\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_mail import Mail\n\ndb = SQLAlchemy()\nmigrate = Migrate(db=db)\nmail = Mail()\n```\n\n\n## Usage with anything else\n\nYou can create your own discovery rules with the `discover()` function, `ModuleRule` and `ObjectRule`. Optionally, you can take advantage of custom matchers, defined in `roman_discovery.matchers`.\n\nFor example, that\'s how you print all modules and all callable objects within the `roman_discovery` itself.\n\n```python\nfrom roman_discovery import discover, ModuleRule, ObjectRule\n\nmodule_printer = ModuleRule(\n    name="module printer",\n    module_matches=lambda module_name: True,\n    module_action=lambda module_name: print(f"Found module {module_name}"),\n)\n\nobject_printer = ObjectRule(\n    name="object printer",\n    module_matches=lambda module_name: True,\n    object_matches=callable,\n    object_action=lambda obj: print(f"Found callable object {obj!r}"),\n)\n\ndiscover("roman_discovery", rules=[module_printer, object_printer])\n```\n\n## Why the "roman" prefix?\n\nI use it as my own "pseudo-namespace." If I ever abandon the project, at least the package doesn\'t occupy a common name.\n',
    'author': 'Roman Imankulov',
    'author_email': 'roman.imankulov@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/imankulov/roman_discovery',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7.8,<4.0',
}


setup(**setup_kwargs)
