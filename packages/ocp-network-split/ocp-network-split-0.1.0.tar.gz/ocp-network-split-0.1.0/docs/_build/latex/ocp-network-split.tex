%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{ocp\sphinxhyphen{}network\sphinxhyphen{}split}
\date{Apr 19, 2021}
\release{}
\author{Martin Bukatovič}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


This simple project provides functionality to block (and unblock) network
traffic between \sphinxhref{https://kubernetes.io/docs/reference/labels-annotations-taints/\#topologykubernetesiozone}{k8s zones} of an \sphinxhref{https://docs.openshift.com/container-platform/4.7/welcome/index.html}{OpenShift 4} cluster for \sphinxstyleemphasis{testing
purposes}, implemented by updating firewall rules on all RHEL CoreOS nodes of
the cluster.

This is useful when you need to separate network between given zones, without
affecting other traffic and with no assumptions about networking configuration
of the platform the cluster is deployed on (under normal conditions, network
separation like this could be done by tweaking network components between
zones).


\chapter{Assumptions and limitations}
\label{\detokenize{assumptions:assumptions-and-limitations}}\label{\detokenize{assumptions:assumptions}}\label{\detokenize{assumptions::doc}}
We assume that the cluster has 3 zones.

There is no limitation on actuall zone names (values of
\sphinxcode{\sphinxupquote{topology.kubernetes.io/zone}} label key).

We assume that the cluster is using IPv4 addresses only.

While Linux kernel of RHEL CoreOS (RHCOS) uses \sphinxcode{\sphinxupquote{nftables}} internally, the
\sphinxcode{\sphinxupquote{iptables}} cli tool which uses \sphinxcode{\sphinxupquote{nftables}} backed is preinstalled on RHCOS
hosts of OCP 4 clusters. The firewall script thus assumes that \sphinxcode{\sphinxupquote{iptables}} cli
tool is available on the nodes of the cluster.

Nodes of openshift cluster keep it’s \sphinxhref{https://docs.openshift.com/container-platform/4.6/post\_installation\_configuration/machine-configuration-tasks.html\#installation-special-config-chrony\_post-install-machine-configuration-tasks}{time synchronized via ntp}.

We assume that there are only \sphinxcode{\sphinxupquote{master}} and \sphinxcode{\sphinxupquote{worker}} MachineConfigPools
(which is the default state of OCP cluster). If you have created another
machine config pool such as \sphinxcode{\sphinxupquote{infra}}, the network split configuration won’t
be able to change firewall rules on nodes in this additional pool.


\chapter{Overview of the approach}
\label{\detokenize{overview:overview-of-the-approach}}\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}
A quick overview of what and how opc\sphinxhyphen{}network\sphinxhyphen{}split does to block network
traffic between cluster zones.


\section{Network split firewall script}
\label{\detokenize{overview:network-split-firewall-script}}
Traffic from zone \sphinxcode{\sphinxupquote{a}} to zone \sphinxcode{\sphinxupquote{b}} is blocked by inserting \sphinxcode{\sphinxupquote{DROP}} rules
for each machine of zone \sphinxcode{\sphinxupquote{b}} into \sphinxcode{\sphinxupquote{INPUT}} and \sphinxcode{\sphinxupquote{OUTPUT}} chains of default
\sphinxcode{\sphinxupquote{iptables}} table on all machines of zone \sphinxcode{\sphinxupquote{a}} via \sphinxcode{\sphinxupquote{iptables}} tool.

This is implemented via \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split.sh}} script, which consumes zone
configuration via \sphinxcode{\sphinxupquote{ZONE\_A}}, \sphinxcode{\sphinxupquote{ZONE\_B}} and \sphinxcode{\sphinxupquote{ZONE\_C}} env variables, detects
zone it is running within and applies firewall changes based on the split
configuration which it received from the command line.

Split configuration specifies list of zone tuples, and the network split is
made for traffic between each zone tuple. For example:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ab}} means that traffic between zone \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} will be dropped in
both directions (via changes in firewall configuration of zone \sphinxcode{\sphinxupquote{a}})

\item {} 
\sphinxcode{\sphinxupquote{ab\sphinxhyphen{}bc}} means that communication in both directions is blocked between
zone \sphinxcode{\sphinxupquote{a}} and zone \sphinxcode{\sphinxupquote{b}}, and also between zone \sphinxcode{\sphinxupquote{b}} and zone \sphinxcode{\sphinxupquote{c}}

\end{itemize}

One can see what changes will be made via \sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{ZONE\PYGZus{}A}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}10.1.161.27\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{ZONE\PYGZus{}B}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}10.1.160.175 10.1.160.180 10.1.160.188 10.1.160.198\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{}} \PYG{n+nb}{export} \PYG{n+nv}{ZONE\PYGZus{}C}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}10.1.161.115 10.1.160.192 10.1.160.174 10.1.160.208\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{}} ./network\PYGZhy{}split.sh \PYGZhy{}d setup ab\PYGZhy{}ac
\PYG{g+go}{ZONE\PYGZus{}A=\PYGZdq{}10.40.195.21\PYGZdq{}}
\PYG{g+go}{ZONE\PYGZus{}B=\PYGZdq{}10.1.160.175 10.1.160.180 10.1.160.188 10.1.160.198\PYGZdq{}}
\PYG{g+go}{ZONE\PYGZus{}C=\PYGZdq{}10.1.161.115 10.1.160.192 10.1.160.174 10.1.160.208\PYGZdq{}}
\PYG{g+go}{current zone: ZONE\PYGZus{}A}
\PYG{g+go}{ab: ZONE\PYGZus{}B will be blocked from ZONE\PYGZus{}A}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.175 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.175 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.180 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.180 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.188 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.188 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.198 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.198 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{ac: ZONE\PYGZus{}C will be blocked from ZONE\PYGZus{}A}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.161.115 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.161.115 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.192 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.192 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.174 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.174 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A INPUT \PYGZhy{}s 10.1.160.208 \PYGZhy{}j DROP \PYGZhy{}v}
\PYG{g+go}{iptables \PYGZhy{}A OUTPUT \PYGZhy{}d 10.1.160.208 \PYGZhy{}j DROP \PYGZhy{}v}
\end{sphinxVerbatim}


\section{Systemd Units}
\label{\detokenize{overview:systemd-units}}
The firewall script is not used directly, but through \sphinxstyleemphasis{stoppable oneshot
service} template \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split@.service}}. To use it, we need to chose
particular network split configuration, eg. \sphinxcode{\sphinxupquote{ab\sphinxhyphen{}bc}},  and then form so
called “instantiated” service name \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split@ab\sphinxhyphen{}ac.service}}.
When such “instantiated” service is started, firewall changes to achieve
selected network split are applied and since then systemd is tracking this
service as started. Stopping the service reverts the firewall changes back,
removing the network split. The logs from the firewall script available via
journald as expected.

Example of starting network split for \sphinxcode{\sphinxupquote{ab\sphinxhyphen{}bc}} and checking it’s status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}} systemctl start  network\PYGZhy{}split@ab\PYGZhy{}bc
\PYG{g+gp}{\PYGZsh{}} systemctl status network\PYGZhy{}split@ab\PYGZhy{}bc
\PYG{g+go}{● network\PYGZhy{}split@ab\PYGZhy{}bc.service \PYGZhy{} Firewall configuration for a network split}
\PYG{g+go}{   Loaded: loaded (/etc/systemd/system/network\PYGZhy{}split@.service; disabled; vendor preset: disabled)}
\PYG{g+go}{   Active: active (exited) since Sat 2021\PYGZhy{}03\PYGZhy{}06 00:23:18 UTC; 4min 49s ago}
\PYG{g+go}{  Process: 16380 ExecStart=/usr/bin/bash \PYGZhy{}c /etc/network\PYGZhy{}split.sh setup ab\PYGZhy{}bc (code=exited, status=0/SUCCESS)}
\PYG{g+go}{ Main PID: 16380 (code=exited, status=0/SUCCESS)}
\PYG{g+go}{      CPU: 8ms}

\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 systemd[1]: Starting Firewall configuration for a network split...}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: ZONE\PYGZus{}A=\PYGZdq{}10.1.161.27\PYGZdq{}}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: ZONE\PYGZus{}B=\PYGZdq{}10.1.160.175 10.1.160.180 10.1.160.188 10.1.160.198\PYGZdq{}}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: ZONE\PYGZus{}C=\PYGZdq{}10.1.161.115 10.1.160.192 10.1.160.174 10.1.160.208\PYGZdq{}}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: current zone: ZONE\PYGZus{}C}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: ab: ZONE\PYGZus{}B will be blocked from ZONE\PYGZus{}A}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 bash[16380]: bc: ZONE\PYGZus{}C will be blocked from ZONE\PYGZus{}B}
\PYG{g+go}{Mar 06 00:23:18 compute\PYGZhy{}5 systemd[1]: Started Firewall configuration for a network split.}
\end{sphinxVerbatim}

This would work well on a single node, but in our case we need to apply this
on multiple machines at the same time. Moreover we also need to make sure that
the service is stopped after some time, reverting the network split issue.
For this reason, we don’t start the network split service directly, but via
systemd timers, which allows us to schedule start and stop of the network split
service in advance at the same time on all nodes of the cluster.

For each network split configuration we have in stretch cluster test plan,
there is one setup timer template which starts the service at given time:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}ab\sphinxhyphen{}ac\sphinxhyphen{}setup@.timer}}

\item {} 
\sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}ab\sphinxhyphen{}setup@.timer}}

\item {} 
\sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}ab\sphinxhyphen{}bc\sphinxhyphen{}setup@.timer}}

\item {} 
\sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}bc\sphinxhyphen{}setup@.timer}}

\end{itemize}

And then single teardown timer template \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}teardown@.timer}},
which is used to schedule stop of any of the network split services to revert
the firewall changes back into original state.

Parameter of these timer templates is a unix epoch timestamp of the time when
we intend to start or stop the network split, eg.
\sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}teardown@1614990498.timer}}.

This is how a network split configuration is applied during test setup,
and restored during test teardown.

References:
\begin{itemize}
\item {} 
\sphinxhref{https://www.freedesktop.org/software/systemd/man/systemd.service.html}{systemd.service(5)}
(for details about service templates or example of stoppable oneshot service)

\item {} 
\sphinxhref{https://www.freedesktop.org/software/systemd/man/systemd.timer.html}{systemd.timer(5)}

\end{itemize}


\section{MachineConfig}
\label{\detokenize{overview:machineconfig}}
For the approach explained above to work, we need to deploy firewall script,
file with \sphinxcode{\sphinxupquote{ZONE\_\{A,B,C\}}} environment variables and systemd service and timer
units. We achieve this via MachineConfig, which allows us to deploy files in
\sphinxcode{\sphinxupquote{/etc}} directory and system units on all nodes of both \sphinxcode{\sphinxupquote{master}} and
\sphinxcode{\sphinxupquote{worker}} MachineConfigPools.

Using openshift interface has an advantage of better visibility of such
changes, which can be easily inspected via machine config operator (MCO) API.
Downside of this approach is that MCO is going to drain and reboot every node
one by one, which increases time necessary to deploy the configuration.

For this reason, we use MachineConfig only to deploy the script and unit files,
while scheduling of the timers to setup and teardown a network split is done
via direct connection (using ssh or oc debug) to each node.

References:
\begin{itemize}
\item {} 
\sphinxhref{https://www.redhat.com/en/blog/openshift-container-platform-4-how-does-machine-config-pool-work}{How does Machine Config Pool work?}

\item {} 
\sphinxhref{https://docs.openshift.com/container-platform/4.6/post\_installation\_configuration/machine-configuration-tasks.html\#using-machineconfigs-to-change-machines}{Post\sphinxhyphen{}installation machine configuration tasks}

\item {} 
\sphinxhref{https://github.com/openshift/machine-config-operator/tree/master/docs}{machine\sphinxhyphen{}config\sphinxhyphen{}operator docs}

\item {} 
\sphinxhref{https://coreos.github.io/ignition/configuration-v3\_1/}{Ignition Configuration Specification v3.1.0}

\end{itemize}


\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage:id1}}\label{\detokenize{usage::doc}}

\section{Assumptions about cluster zones}
\label{\detokenize{usage:assumptions-about-cluster-zones}}
A \sphinxhref{https://kubernetes.io/docs/reference/labels-annotations-taints/\#topologykubernetesiozone}{k8s zone} is a set of cluster nodes with the same value of \sphinxhref{https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/}{k8s label} key
\sphinxcode{\sphinxupquote{topology.kubernetes.io/zone}}, see an example of zone \sphinxcode{\sphinxupquote{data\sphinxhyphen{}a}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} oc get nodes \PYGZhy{}l topology.kubernetes.io/zone\PYG{o}{=}data\PYGZhy{}a
\PYG{g+go}{NAME              STATUS   ROLES    AGE     VERSION}
\PYG{g+go}{compute\PYGZhy{}0         Ready    worker   7d14h   v1.20.0+bafe72f}
\PYG{g+go}{compute\PYGZhy{}1         Ready    worker   7d14h   v1.20.0+bafe72f}
\PYG{g+go}{compute\PYGZhy{}2         Ready    worker   7d14h   v1.20.0+bafe72f}
\PYG{g+go}{control\PYGZhy{}plane\PYGZhy{}0   Ready    master   7d14h   v1.20.0+bafe72f}
\end{sphinxVerbatim}

We assume that there are 3 zones in the cluster, and that every node belongs to
some zone, eg:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} oc get nodes \PYGZhy{}L topology.kubernetes.io/zone
\PYG{g+go}{NAME              STATUS   ROLES    AGE   VERSION           ZONE}
\PYG{g+go}{compute\PYGZhy{}0         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}a}
\PYG{g+go}{compute\PYGZhy{}1         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}a}
\PYG{g+go}{compute\PYGZhy{}2         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}a}
\PYG{g+go}{compute\PYGZhy{}3         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}b}
\PYG{g+go}{compute\PYGZhy{}4         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}b}
\PYG{g+go}{compute\PYGZhy{}5         Ready    worker   8d    v1.20.0+bafe72f   data\PYGZhy{}b}
\PYG{g+go}{control\PYGZhy{}plane\PYGZhy{}0   Ready    master   8d    v1.20.0+bafe72f   data\PYGZhy{}a}
\PYG{g+go}{control\PYGZhy{}plane\PYGZhy{}1   Ready    master   8d    v1.20.0+bafe72f   data\PYGZhy{}b}
\PYG{g+go}{control\PYGZhy{}plane\PYGZhy{}2   Ready    master   8d    v1.20.0+bafe72f   arbiter}
\end{sphinxVerbatim}

There is no limitation on the design of cluster zones or their names
(values of \sphinxcode{\sphinxupquote{topology.kubernetes.io/zone}} label key). The ocp\sphinxhyphen{}network\sphinxhyphen{}split
references zones under single letter names (such as \sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}} … see
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZONES}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.ZONES}}}}}), so that you will just need to
create mapping between ocp\sphinxhyphen{}network\sphinxhyphen{}split names and actual zone names as shown
in the following sections.


\section{Command line tools}
\label{\detokenize{usage:command-line-tools}}
There are also 2 command line tools:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ocp\sphinxhyphen{}network\sphinxhyphen{}split\sphinxhyphen{}setup}}: based on given zone name assignment, it fetches
IP addresses of all nodes for every zone (to create env file with zone
configuration), and creates \sphinxcode{\sphinxupquote{MachineConfig}} yaml file to deploy the zone
configuration along with firewall script and systemd unit files to every node
of the cluster. This is done only once.

\item {} 
\sphinxcode{\sphinxupquote{ocp\sphinxhyphen{}network\sphinxhyphen{}split\sphinxhyphen{}sched}}: schedules given network split configuration
which will start at given time and stop after given number of minutes.

\end{itemize}

Let’s have a look how the zone configuration generated by the setup script
looks like (the example also shows how to define zone name mapping):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}setup \PYGZhy{}a arbiter \PYGZhy{}b data\PYGZhy{}a \PYGZhy{}c data\PYGZhy{}b \PYGZhy{}\PYGZhy{}print\PYGZhy{}env\PYGZhy{}only
\PYG{g+go}{ZONE\PYGZus{}A=\PYGZdq{}10.1.160.36\PYGZdq{}}
\PYG{g+go}{ZONE\PYGZus{}B=\PYGZdq{}10.1.160.127 10.1.160.158 10.1.160.160 10.1.160.163\PYGZdq{}}
\PYG{g+go}{ZONE\PYGZus{}C=\PYGZdq{}10.1.160.103 10.1.160.162 10.1.160.65 10.1.160.98\PYGZdq{}}
\end{sphinxVerbatim}

If this looks good, we can go on and create \sphinxcode{\sphinxupquote{MachineConfig}} yaml file, which
you can inspect as well.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}setup \PYGZhy{}a foo\PYGZhy{}arbiter \PYGZhy{}b data\PYGZhy{}a \PYGZhy{}c data\PYGZhy{}b \PYGZhy{}o network\PYGZhy{}split.yaml
\PYG{g+gp}{\PYGZdl{}} head network\PYGZhy{}split.yaml
\PYG{g+go}{apiVersion: machineconfiguration.openshift.io/v1}
\PYG{g+go}{kind: MachineConfig}
\PYG{g+go}{metadata:}
\PYG{g+go}{  labels:}
\PYG{g+go}{    machineconfiguration.openshift.io/role: master}
\PYG{g+go}{  name: 99\PYGZhy{}master\PYGZhy{}network\PYGZhy{}split}
\PYG{g+go}{spec:}
\PYG{g+go}{  config:}
\PYG{g+go}{    ignition:}
\PYG{g+go}{      version: 3.1.0}
\end{sphinxVerbatim}

Then you can use \sphinxcode{\sphinxupquote{oc create}} to deploy the configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} oc create \PYGZhy{}f network\PYGZhy{}split.yaml
\PYG{g+go}{machineconfig.machineconfiguration.openshift.io/99\PYGZhy{}master\PYGZhy{}network\PYGZhy{}split created}
\PYG{g+go}{machineconfig.machineconfiguration.openshift.io/99\PYGZhy{}worker\PYGZhy{}network\PYGZhy{}split created}
\end{sphinxVerbatim}

When the machine config is applied (check \sphinxcode{\sphinxupquote{oc get mcp}} if both pools are
updated), we can schedule 5 minute long network split of particular
configuration \sphinxcode{\sphinxupquote{ab}} (cutting connection between zones \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}) at
given time:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}sched ab \PYGZhy{}t \PYG{l+m}{2021}\PYGZhy{}04\PYGZhy{}09T16:30 \PYGZhy{}\PYGZhy{}split\PYGZhy{}len \PYG{l+m}{5}
\end{sphinxVerbatim}

When the time details are omitted, the sched script will just list net split
timers for given split configuration on all nodes. In the following example,
we can see one split was schedule 26 minutes ago, while anoter is going to
happen in about 4 minutes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}sched ab
\PYG{g+go}{node/compute\PYGZhy{}0}
\PYG{g+go}{NEXT                         LEFT          LAST                         PASSED    UNIT                                    ACTIVATES}
\PYG{g+go}{Fri 2021\PYGZhy{}04\PYGZhy{}09 14:30:00 UTC  3min 50s left n/a                          n/a       network\PYGZhy{}split\PYGZhy{}ab\PYGZhy{}setup@1617978600.timer network\PYGZhy{}split@ab.service}
\PYG{g+go}{n/a                          n/a           Fri 2021\PYGZhy{}04\PYGZhy{}09 14:00:00 UTC  26min ago network\PYGZhy{}split\PYGZhy{}ab\PYGZhy{}setup@1617976800.timer network\PYGZhy{}split@ab.service}

\PYG{g+go}{node/compute\PYGZhy{}1}
\PYG{g+go}{NEXT                         LEFT          LAST                         PASSED    UNIT                                    ACTIVATES}
\PYG{g+go}{Fri 2021\PYGZhy{}04\PYGZhy{}09 14:30:00 UTC  3min 48s left n/a                          n/a       network\PYGZhy{}split\PYGZhy{}ab\PYGZhy{}setup@1617978600.timer network\PYGZhy{}split@ab.service}
\PYG{g+go}{n/a                          n/a           Fri 2021\PYGZhy{}04\PYGZhy{}09 14:00:00 UTC  26min ago network\PYGZhy{}split\PYGZhy{}ab\PYGZhy{}setup@1617976800.timer network\PYGZhy{}split@ab.service}

\PYG{g+go}{... rest of the output is ommited ...}
\end{sphinxVerbatim}

You can schedule multiple splits in advance, or wait for one network split to
end before going on with another one.


\section{Python API}
\label{\detokenize{usage:python-api}}
To use ocp\sphinxhyphen{}network\sphinxhyphen{}split in your python test script, see functions in module
{\hyperref[\detokenize{ocpnetsplit:module-ocpnetsplit.main}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.main}}}}} which provides public API and implementation
of the command line tools referenced in the previous section.

Quick high level overview of API usage:
\begin{itemize}
\item {} 
Generate list of dictionaries representing content of \sphinxcode{\sphinxupquote{MachineConfig}} yaml,
(which contains network split script and unit files) using
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.main.get_zone_config}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.main.get\_zone\_config()}}}}} and
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.main.get_networksplit_mc_spec}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.main.get\_networksplit\_mc\_spec()}}}}}.

\item {} 
Deploy the \sphinxcode{\sphinxupquote{MachineConfig}} generated in the previous step and wait for the
configuration to be applied on all nodes. This needs to be done only once.

\item {} 
Pick desired network split configuration from
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.NETWORK_SPLITS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.NETWORK\_SPLITS}}}}}.

\item {} 
Schedule selected network split disruption via
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.main.schedule_split}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.main.schedule\_split()}}}}}, this will define 2 timers
on each node, one to start the disruption and another one to stop it.

\item {} 
Wait for the 1st timer to trigger setup of the network split.

\item {} 
Wait for the 2nd timer to trigger teardown, restoring the network
configuration back.

\item {} 
Optionally schedule another network split again.

\end{itemize}


\chapter{API Reference}
\label{\detokenize{modules:api-reference}}\label{\detokenize{modules::doc}}

\section{ocpnetsplit package}
\label{\detokenize{ocpnetsplit:ocpnetsplit-package}}\label{\detokenize{ocpnetsplit::doc}}

\subsection{ocpnetsplit.machineconfig module}
\label{\detokenize{ocpnetsplit:module-ocpnetsplit.machineconfig}}\label{\detokenize{ocpnetsplit:ocpnetsplit-machineconfig-module}}\index{module@\spxentry{module}!ocpnetsplit.machineconfig@\spxentry{ocpnetsplit.machineconfig}}\index{ocpnetsplit.machineconfig@\spxentry{ocpnetsplit.machineconfig}!module@\spxentry{module}}
This module generates \sphinxcode{\sphinxupquote{MachineConfig}} to deploy network\sphinxhyphen{}split systemd units,
which implements the network split functionality.

References:
\begin{itemize}
\item {} 
\sphinxhref{https://github.com/openshift/machine-config-operator/blob/master/docs/MachineConfigDaemon.md}{MachineConfigDaemon}

\item {} 
\sphinxhref{https://coreos.github.io/ignition/configuration-v3\_1/}{Ignition Configuration Specification v3.1.0}

\end{itemize}
\index{create\_file\_dict() (in module ocpnetsplit.machineconfig)@\spxentry{create\_file\_dict()}\spxextra{in module ocpnetsplit.machineconfig}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.machineconfig.create_file_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.machineconfig.}}\sphinxbfcode{\sphinxupquote{create\_file\_dict}}}{\emph{\DUrole{n}{basename}}, \emph{\DUrole{n}{content}}}{}
Create Ignition config spec for given file basename and content, to be used
in a \sphinxcode{\sphinxupquote{MachineConfig}} spec. Files will be always placed in \sphinxcode{\sphinxupquote{/etc}}
directory (MCO can only change files in \sphinxcode{\sphinxupquote{/etc}} and \sphinxcode{\sphinxupquote{/var}} directories).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} basename of the file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{content}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} content of the file

\end{itemize}

\item[{Returns}] \leavevmode
Ignition storage file config spec

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_mc\_dict() (in module ocpnetsplit.machineconfig)@\spxentry{create\_mc\_dict()}\spxextra{in module ocpnetsplit.machineconfig}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.machineconfig.create_mc_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.machineconfig.}}\sphinxbfcode{\sphinxupquote{create\_mc\_dict}}}{\emph{\DUrole{n}{role}}, \emph{\DUrole{n}{zone\_env}}}{}
Create \sphinxcode{\sphinxupquote{MachineConfig}} dict with network\sphinxhyphen{}split systemd units and scripts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mcp}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of \sphinxcode{\sphinxupquote{MachineConfig}} role (and also
\sphinxcode{\sphinxupquote{MachineConfigPool}}) where the \sphinxcode{\sphinxupquote{MachineConfig}} generated by
this function should be deployed. Usually \sphinxcode{\sphinxupquote{master}} or \sphinxcode{\sphinxupquote{worker}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_env}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} content of \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split.env}} file with zone
configuration, as created by
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.get_env_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.ZoneConfig.get\_env\_file()}}}}}

\end{itemize}

\item[{Returns}] \leavevmode
MachineConfig dict

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_unit\_dict() (in module ocpnetsplit.machineconfig)@\spxentry{create\_unit\_dict()}\spxextra{in module ocpnetsplit.machineconfig}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.machineconfig.create_unit_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.machineconfig.}}\sphinxbfcode{\sphinxupquote{create\_unit\_dict}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{content}}}{}
Create Ignition config spec for given systemd unit name and content, to be
used in a \sphinxcode{\sphinxupquote{MachineConfig}} spec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of systemd unit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{content}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} content of the file

\end{itemize}

\item[{Returns}] \leavevmode
Ignition systemd unit config spec

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}



\subsection{ocpnetsplit.main module}
\label{\detokenize{ocpnetsplit:module-ocpnetsplit.main}}\label{\detokenize{ocpnetsplit:ocpnetsplit-main-module}}\index{module@\spxentry{module}!ocpnetsplit.main@\spxentry{ocpnetsplit.main}}\index{ocpnetsplit.main@\spxentry{ocpnetsplit.main}!module@\spxentry{module}}
Module with a public API of ocp\sphinxhyphen{}network\sphinxhyphen{}split project. One can either use the
command line tools (as implemented via main functions in this module), or to
use the python functions defined here directly.
\index{check\_split() (in module ocpnetsplit.main)@\spxentry{check\_split()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.check_split}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{check\_split}}}{\emph{\DUrole{n}{split\_name}}}{}
Checks status of split via \sphinxcode{\sphinxupquote{systemctl list\sphinxhyphen{}timers}} on all nodes of the
cluster.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{split\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} network split configuration specification, eg.
\sphinxcode{\sphinxupquote{ab}}, see {\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.NETWORK_SPLITS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.NETWORK\_SPLITS}}}}}
constant

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} when invalid \sphinxcode{\sphinxupquote{split\_name}} is specified

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_networksplit\_mc\_spec() (in module ocpnetsplit.main)@\spxentry{get\_networksplit\_mc\_spec()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.get_networksplit_mc_spec}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{get\_networksplit\_mc\_spec}}}{\emph{\DUrole{n}{zone\_env}}}{}
Create \sphinxcode{\sphinxupquote{MachineConfig}} spec to install network split firewall tweaking
script and unit files on all cluster nodes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{zone\_env}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} content of firewall zone env file specifying node ip
addresses for each cluster zone, as created by
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.get_env_file}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.ZoneConfig.get\_env\_file()}}}}}

\item[{Returns}] \leavevmode
list of dictionaries with \sphinxcode{\sphinxupquote{MachineConfig}} spec

\item[{Return type}] \leavevmode
machineconfig\_spec

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_zone\_config() (in module ocpnetsplit.main)@\spxentry{get\_zone\_config()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.get_zone_config}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{get\_zone\_config}}}{\emph{\DUrole{n}{zone\_a}}, \emph{\DUrole{n}{zone\_b}}, \emph{\DUrole{n}{zone\_c}}, \emph{\DUrole{n}{zone\_x\_addrs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
For each valid ocp\sphinxhyphen{}network\sphinxhyphen{}split zone name (see
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZONES}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.ZONES}}}}}), translate it’s given
\sphinxcode{\sphinxupquote{topology.kubernetes.io/zone}} label into list of ip addresses of all
nodes in the zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_a}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} value of zone \sphinxcode{\sphinxupquote{a}} label

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_b}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} value of zone \sphinxcode{\sphinxupquote{b}} label

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_c}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} value of zone \sphinxcode{\sphinxupquote{c}} label

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_x\_addrs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of ip addresses in external zone \sphinxcode{\sphinxupquote{x}}

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{object with list of node ip addresses for each zone name}] \leavevmode
\sphinxstyleemphasis{ocp network split} works with (\sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}}, …),
see {\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZONES}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.ZONES}}}}}).

\end{description}


\item[{Return type}] \leavevmode
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig}]{\sphinxcrossref{ZoneConfig}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{main\_sched() (in module ocpnetsplit.main)@\spxentry{main\_sched()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.main_sched}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{main\_sched}}}{}{}
Simple command line interface to schedule given cluster network split.

Example usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}sched ab\PYGZhy{}bc \PYGZhy{}t 2021\PYGZhy{}03\PYGZhy{}18T18:45 \PYGZhy{}\PYGZhy{}split\PYGZhy{}len 30
\PYGZdl{} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}sched ab\PYGZhy{}bc
\end{sphinxVerbatim}

\end{fulllineitems}

\index{main\_setup() (in module ocpnetsplit.main)@\spxentry{main\_setup()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.main_setup}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{main\_setup}}}{}{}
Simple command line interface to generate MachineConfig yaml to deploy to
make scheduling network splits possible.

Example usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ocp\PYGZhy{}network\PYGZhy{}split\PYGZhy{}setup \PYGZhy{}a arbiter \PYGZhy{}b d1 \PYGZhy{}c d2 \PYGZhy{}o mc.yaml
\PYGZdl{} oc create \PYGZhy{}f mc.yaml
\PYGZdl{} oc get mcp
\end{sphinxVerbatim}

\end{fulllineitems}

\index{schedule\_split() (in module ocpnetsplit.main)@\spxentry{schedule\_split()}\spxextra{in module ocpnetsplit.main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.main.schedule_split}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.main.}}\sphinxbfcode{\sphinxupquote{schedule\_split}}}{\emph{\DUrole{n}{split\_name}}, \emph{\DUrole{n}{target\_dt}}, \emph{\DUrole{n}{target\_length}}}{}
Schedule start and stop of network split on all nodes of the cluster.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{split\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} network split configuration specification, eg.
\sphinxcode{\sphinxupquote{ab}}, see
{\hyperref[\detokenize{ocpnetsplit:ocpnetsplit.zone.NETWORK_SPLITS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.NETWORK\_SPLITS}}}}} constant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target\_dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{datetime}}) \textendash{} requested start time of the network split

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target\_length}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of minutes specifying how long the network
split configuration should be active

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} in case invalid \sphinxcode{\sphinxupquote{split\_name}} or \sphinxcode{\sphinxupquote{target\_dt}} is
    specified.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{ocpnetsplit.ocp module}
\label{\detokenize{ocpnetsplit:module-ocpnetsplit.ocp}}\label{\detokenize{ocpnetsplit:ocpnetsplit-ocp-module}}\index{module@\spxentry{module}!ocpnetsplit.ocp@\spxentry{ocpnetsplit.ocp}}\index{ocpnetsplit.ocp@\spxentry{ocpnetsplit.ocp}!module@\spxentry{module}}\index{get\_all\_node\_ip\_addrs() (in module ocpnetsplit.ocp)@\spxentry{get\_all\_node\_ip\_addrs()}\spxextra{in module ocpnetsplit.ocp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.ocp.get_all_node_ip_addrs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.ocp.}}\sphinxbfcode{\sphinxupquote{get\_all\_node\_ip\_addrs}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{kubeconfig}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{oc\_executable}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get all ip addresses (both internal and external) of given node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of OCP node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kubeconfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path to kubeconfig (optional, use only if you
need to override the default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oc\_executable}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path of oc command (optional, use only if
you need to override the default)

\end{itemize}

\item[{Returns}] \leavevmode
node ip addressess (as strings)

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{list\_cluster\_nodes() (in module ocpnetsplit.ocp)@\spxentry{list\_cluster\_nodes()}\spxextra{in module ocpnetsplit.ocp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.ocp.list_cluster_nodes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.ocp.}}\sphinxbfcode{\sphinxupquote{list\_cluster\_nodes}}}{\emph{\DUrole{n}{zone\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{kubeconfig}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{oc\_executable}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get cluster nodes of a whole cluster or from given zone only.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of k8s topology zone to list nodes within, if not
specified, nodes from whole cluster will be listed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kubeconfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path to kubeconfig (optional, use only if you
need to override the default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oc\_executable}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path of oc command (optional, use only if
you need to override the default)

\end{itemize}

\item[{Returns}] \leavevmode
node ip addressess (as strings)

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_oc() (in module ocpnetsplit.ocp)@\spxentry{run\_oc()}\spxextra{in module ocpnetsplit.ocp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.ocp.run_oc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.ocp.}}\sphinxbfcode{\sphinxupquote{run\_oc}}}{\emph{\DUrole{n}{cmd\_list}}, \emph{\DUrole{n}{kubeconfig}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{oc\_executable}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{timeout}\DUrole{o}{=}\DUrole{default_value}{600}}}{}
Run given oc command and log all it’s output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmd\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} oc command to run, eg. \sphinxcode{\sphinxupquote{{[}"get", "nodes"{]}}} will
execute \sphinxcode{\sphinxupquote{oc get nodes}} process

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timeout}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} command timeout specified in seconds, optional

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kubeconfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path to kubeconfig (optional, use only if you
need to override the default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oc\_executable}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path of oc command (optional, use only if
you need to override the default)

\end{itemize}

\item[{Returns}] \leavevmode
stdout, stderr of the command executed

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_oc\_debug\_node() (in module ocpnetsplit.ocp)@\spxentry{run\_oc\_debug\_node()}\spxextra{in module ocpnetsplit.ocp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.ocp.run_oc_debug_node}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ocpnetsplit.ocp.}}\sphinxbfcode{\sphinxupquote{run\_oc\_debug\_node}}}{\emph{\DUrole{n}{cmd\_list}}, \emph{\DUrole{n}{node}}, \emph{\DUrole{n}{kubeconfig}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{oc\_executable}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Run given command on given node via oc debug node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmd\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} a command to run, eg. \sphinxcode{\sphinxupquote{{[}"uname", "\sphinxhyphen{}a"{]}}} will
execute \sphinxcode{\sphinxupquote{uname \sphinxhyphen{}a}} process on the node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of k8s node where to execute the command, with or
without \sphinxcode{\sphinxupquote{node/}} prefix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kubeconfig}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path to kubeconfig (optional, use only if you
need to override the default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oc\_executable}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path of oc command (optional, use only if
you need to override the default)

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{cmd\_out (combined stdout and stderr of the executed command),}] \leavevmode
oc\_out (output from oc debug process itself)

\end{description}


\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}



\subsection{ocpnetsplit.zone module}
\label{\detokenize{ocpnetsplit:module-ocpnetsplit.zone}}\label{\detokenize{ocpnetsplit:ocpnetsplit-zone-module}}\index{module@\spxentry{module}!ocpnetsplit.zone@\spxentry{ocpnetsplit.zone}}\index{ocpnetsplit.zone@\spxentry{ocpnetsplit.zone}!module@\spxentry{module}}\index{NETWORK\_SPLITS (in module ocpnetsplit.zone)@\spxentry{NETWORK\_SPLITS}\spxextra{in module ocpnetsplit.zone}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.NETWORK_SPLITS}}\pysigline{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.}}\sphinxbfcode{\sphinxupquote{NETWORK\_SPLITS}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}ab\textquotesingle{}, \textquotesingle{}bc\textquotesingle{}, \textquotesingle{}ab\sphinxhyphen{}bc\textquotesingle{}, \textquotesingle{}ab\sphinxhyphen{}ac\textquotesingle{}, \textquotesingle{}ax\textquotesingle{}, \textquotesingle{}ax\sphinxhyphen{}bx\sphinxhyphen{}cx\textquotesingle{})}}}
Available network split configurations. For every valid network split value,
there is a systemd timer unit named \sphinxcode{\sphinxupquote{network\sphinxhyphen{}split\sphinxhyphen{}\{split\}\sphinxhyphen{}setup@.timer}}.
Network split configuration consists of list of zone tuples, where each zone
tuple represents a disrupted zone connection.

\end{fulllineitems}

\index{ZONES (in module ocpnetsplit.zone)@\spxentry{ZONES}\spxextra{in module ocpnetsplit.zone}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZONES}}\pysigline{\sphinxcode{\sphinxupquote{ocpnetsplit.zone.}}\sphinxbfcode{\sphinxupquote{ZONES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{}, \textquotesingle{}x\textquotesingle{})}}}
Stable zone identifiers as defined and used by ocp\sphinxhyphen{}network\sphinxhyphen{}split.

\end{fulllineitems}

\index{ZoneConfig (class in ocpnetsplit.zone)@\spxentry{ZoneConfig}\spxextra{class in ocpnetsplit.zone}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{ocpnetsplit.zone.}}\sphinxbfcode{\sphinxupquote{ZoneConfig}}}
Bases: \sphinxcode{\sphinxupquote{object}}

ZoneConfig is tracking ip addresses of nodes in each cluster zone.
\index{add\_node() (ocpnetsplit.zone.ZoneConfig method)@\spxentry{add\_node()}\spxextra{ocpnetsplit.zone.ZoneConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{\DUrole{n}{zone}}, \emph{\DUrole{n}{node}}}{}
Add a node ip address into a zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} zone identification (one of \sphinxcode{\sphinxupquote{ZONES}})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} ip address of a node

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_nodes() (ocpnetsplit.zone.ZoneConfig method)@\spxentry{add\_nodes()}\spxextra{ocpnetsplit.zone.ZoneConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{\DUrole{n}{zone}}, \emph{\DUrole{n}{nodes}}}{}
Add list of node ip addresses into a zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} zone identification (one of \sphinxcode{\sphinxupquote{ZONES}})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of string representation of node ip addresses

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_env\_file() (ocpnetsplit.zone.ZoneConfig method)@\spxentry{get\_env\_file()}\spxextra{ocpnetsplit.zone.ZoneConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.get_env_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_env\_file}}}{}{}
Generate content of env file for firewall script.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
content of firewall environment file with zone configuration

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nodes() (ocpnetsplit.zone.ZoneConfig method)@\spxentry{get\_nodes()}\spxextra{ocpnetsplit.zone.ZoneConfig method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ocpnetsplit:ocpnetsplit.zone.ZoneConfig.get_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_nodes}}}{\emph{\DUrole{n}{zone}}}{}
Return set of node ip addresses in given zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{zone}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} zone identification (one of \sphinxcode{\sphinxupquote{ZONES}})

\item[{Returns}] \leavevmode
string representation of node ip addresses of given zone

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{o}
\item\relax\sphinxstyleindexentry{ocpnetsplit.machineconfig}\sphinxstyleindexpageref{ocpnetsplit:\detokenize{module-ocpnetsplit.machineconfig}}
\item\relax\sphinxstyleindexentry{ocpnetsplit.main}\sphinxstyleindexpageref{ocpnetsplit:\detokenize{module-ocpnetsplit.main}}
\item\relax\sphinxstyleindexentry{ocpnetsplit.ocp}\sphinxstyleindexpageref{ocpnetsplit:\detokenize{module-ocpnetsplit.ocp}}
\item\relax\sphinxstyleindexentry{ocpnetsplit.zone}\sphinxstyleindexpageref{ocpnetsplit:\detokenize{module-ocpnetsplit.zone}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}