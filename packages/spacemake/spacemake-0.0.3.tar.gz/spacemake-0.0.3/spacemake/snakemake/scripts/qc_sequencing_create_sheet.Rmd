---
iutput:
  html_document:
    toc: true
    toc_depth: 4
version: 0.1.1
author: Tamas Ryszard Sztanka-Toth, Nikolaos Karaiskos
email: tamasryszard.sztanka-toth@mdc-berlin.de, nikolaos.karaiskos@mdc.berlin.de
license: GPL
---

```{r knitr_options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  autodep = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = NA
)
```

```{r libraries, include = F, cache=F}
library(tidyverse)
library(yaml)
library(knitr)
library(magrittr)
library(kableExtra)
library(cowplot)
library(grid)
library(gtable)

theme_set(theme_cowplot(18))

cpalette <- list('orange' = '#D55E00', 'blue' = '#0072B2', 'green' = '#009E73', 'black' = '#000000', 'yellow' = '#F0E442', 
				 'grey' = '#999999', 'light_orange' = "#E69F00", 'light_blue' = "#56B4E9")

readStarLog <- function(log_file){

		out = list()
		lines = readLines(log_file)
	
		out$input_reads = (lines[6] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		out$uniq_mapped_reads = (lines[9] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

        out$multi_mapped_reads = (lines[24] %>% strsplit('\t') %>% unlist)[2] %>% as.integer

		out$avg_mapped_length = (lines[11] %>% strsplit('\t') %>% unlist)[2] %>% as.numeric

        out$unmapped_too_short = (lines[31] %>% strsplit('\t') %>% unlist)[2] %>% as.integer
		
        tibble(observation=names(out), value=unlist(unname(out)))
	}
shift_legend <- function(p){
  # function copied from: https://stackoverflow.com/questions/54438495/shift-legend-into-empty-facets-of-a-faceted-plot-in-ggplot2
  # check if p is a valid object
  if(!"gtable" %in% class(p)){
    if("ggplot" %in% class(p)){
      gp <- ggplotGrob(p) # convert to grob
    } else {
      message("This is neither a ggplot object nor a grob generated from ggplotGrob. Returning original plot.")
      return(p)
    }
  } else {
    gp <- p
  }

  # check for unfilled facet panels
  facet.panels <- grep("^panel", gp[["layout"]][["name"]])
  empty.facet.panels <- sapply(facet.panels, function(i) "zeroGrob" %in% class(gp[["grobs"]][[i]]))
  empty.facet.panels <- facet.panels[empty.facet.panels]
  if(length(empty.facet.panels) == 0){
    message("There are no unfilled facet panels to shift legend into. Returning original plot.")
    return(p)
  }

  # establish extent of unfilled facet panels (including any axis cells in between)
  empty.facet.panels <- gp[["layout"]][empty.facet.panels, ]
  empty.facet.panels <- list(min(empty.facet.panels[["t"]]), min(empty.facet.panels[["l"]]),
                             max(empty.facet.panels[["b"]]), max(empty.facet.panels[["r"]]))
  names(empty.facet.panels) <- c("t", "l", "b", "r")

  # extract legend & copy over to location of unfilled facet panels
  guide.grob <- which(gp[["layout"]][["name"]] == "guide-box")
  if(length(guide.grob) == 0){
    message("There is no legend present. Returning original plot.")
    return(p)
  }
  gp <- gtable_add_grob(x = gp,
                        grobs = gp[["grobs"]][[guide.grob]],
                        t = empty.facet.panels[["t"]],
                        l = empty.facet.panels[["l"]],
                        b = empty.facet.panels[["b"]],
                        r = empty.facet.panels[["r"]],
                        name = "new-guide-box")

  # squash the original guide box's row / column (whichever applicable)
  # & empty its cell
  guide.grob <- gp[["layout"]][guide.grob, ]
  if(guide.grob[["l"]] == guide.grob[["r"]]){
    gp <- gtable_squash_cols(gp, cols = guide.grob[["l"]])
  }
  if(guide.grob[["t"]] == guide.grob[["b"]]){
    gp <- gtable_squash_rows(gp, rows = guide.grob[["t"]])
  }
  gp <- gtable_remove_grobs(gp, "guide-box")

  return(gp)
}
```

```{r save_snakemake, echo = F}
#write_rds(snakemake, '/scratch/home/tsztank/snakemake.rds')
#snakemake <- read_rds('/scratch/home/tsztank/snakemake.rds')
```

```{r read_sample_information_tables, echo = F}
run_mode_settings <- bind_rows(snakemake@params$run_mode) %>%
    nest(umi_cutoff = c(umi_cutoff)) %>%
    bind_cols(tibble(run_mode = names(snakemake@params$run_mode))) %>%
    gather('variable_name', 'value', -run_mode) %>%
    spread(run_mode, value)

run_mode_names <- run_mode_settings[-1] %>% names
run_mode_n <- length(run_mode_names)

sample_info <- bind_rows(snakemake@params$sample_info) %>%
    select(species, sequencing_date, investigator, experiment,
           puck_barcode_file) %>%
    unique %>%
    gather('info_name', 'value') %>%
    add_row(info_name = 'project_id',
            value = snakemake@wildcards$project, .before=1)%>%
    add_row(info_name = 'sample_id',
            value = snakemake@wildcards$sample, .after=1)%>%
    add_row(info_name = 'puck_id',
            value = snakemake@wildcards$puck, .after=2)

cPalette = list('grey'= "#999999", 'light_orange'="#E69F00",
         'light_blue'="#56B4E9", 'green' = "#009E73",
         'yellow' = "#F0E442", 'blue'= "#0072B2", 'orange'="#D55E00",
         'pink'="#CC79A7")

clrs = c('umis'=cPalette$light_orange, 'genes' = cPalette$light_blue, 'reads'=cPalette$green,
         'pcr'=cPalette$pink)

summarised_clrs = c(clrs, 'black')
names(summarised_clrs) = c(paste0('median_', names(clrs)), 'log10_n_beads')

nucl_clrs = c('A'='#F5C900',
              'C'='#F55D59',
              'T'='#3AA861',
              'G'='#7772F5',
              'N'='#999999')
```

### Overview {.tabset}

#### Sample info

```{r show_sample_info, echo = F}
sample_info %>%
    kbl(col.names=NULL) %>%
    kable_classic_2(full_width=F, position='left')
```

#### Run modes

This sample was processed using the following run modes, and run mode variables

```{r plot_run_modes, echo = F}
col_names_to_show <- colnames(run_mode_settings)[-1]

run_mode_settings %>%
    kbl(col.names = c('', col_names_to_show)) %>%
    kable_classic_2(full_width=F, position='left') %>%
    add_header_above(c(" ", "Run modes" = length(col_names_to_show))) %>%
    column_spec(1, border_right=T) %>%
    row_spec(0, bold=T)
```

```{r load_read_statistics, echo =F}
rRNA_stats <- read_table2(snakemake@input$ribo_log, col_names=c('observation', 'value')) %>%
    spread(observation, value) %>%
    mutate(mapped_to_rRNA = aligned_reads) %>%
    gather('observation', 'value') %>%
    filter(observation == 'mapped_to_rRNA') %>%
    mutate(value = ifelse(value == 'None', 0, value))
 
read_stats <- tibble(star_logs = snakemake@input$star_log,
                     reads_type_out = snakemake@input$reads_type_out) %>%
    mutate(trimmed = ifelse(grepl('polyA_adapter_trimmed', reads_type_out, fixed=TRUE),
                            'polyA_adapter_trimmed', 'untrimmed')) %>%
    mutate(star_log_dat = map(star_logs, ~ readStarLog(.)),
           reads_type_out_dat = map(reads_type_out, ~ read_table2(.,
                                                                  col_names = c('observation',
                                                                                'value')))) %>%
    mutate(rRNA_stats_dat = map(star_logs, ~ rbind(rRNA_stats))) %>%
    select(-star_logs, -reads_type_out) %>%
    gather('dat_type', 'dat', -trimmed) %>%
    select(-dat_type) %>%
    unnest(dat) %>%
    group_by(trimmed) %>%
    #rbind(rRNA_stats) %>%
    # convert to millions
    mutate(value = ifelse(observation != 'avg_mapped_length',
                          round(value / 1e6, 2), value)) %>%
    # add input_reads as a column per group
    spread(observation, value) %>%
    mutate(inp_reads = input_reads) %>%
    gather('observation', 'value', -trimmed, -inp_reads) %>%
    mutate(label = ifelse(observation %in% c('input_reads', 'avg_mapped_length'),
                          value, paste0(value, ' (', round(value/inp_reads*100, 1), '%)'))) %>%
    dplyr::select(observation, label) %>%
    spread(observation, label) %>%
    dplyr::rename(as.utr = UTR,
                  intronic = INTRONIC,
                  intergenic = INTERGENIC,
                  ambiguous = AMB,
                  as.cds = CODING) %>%
    # reorder columns
    dplyr::select(input_reads, uniq_mapped_reads, avg_mapped_length, multi_mapped_reads, 
                  unmapped_too_short, intergenic, intronic, as.cds, ambiguous, as.utr,
                  mapped_to_rRNA) %>%
    gather('metric', 'value', -trimmed) %>%
    spread(trimmed, value) %>%
    # change order
    slice(5, 10, 2,3,7,6,1,4,9,11,8)

map_types = colnames(select(read_stats, -metric))
```

#### Mapping statistics

The sample was mapped using `r map_types` reads. The mapping statistics are shown here for each method:

```{r show_read_stats, echo = F}
col_names_to_show <- colnames(read_stats)[-1]
read_stats %>%
    kbl(col.names = c('', col_names_to_show)) %>%
    kable_classic_2(full_width=F, position='left') %>%
    add_header_above(c(" ", "Mapping mode" = length(col_names_to_show))) %>%
    column_spec(1, border_right=T) %>%
    row_spec(0, bold=T) %>%
    add_indent(c(3,4,5,6,7)) %>%
    footnote(general ='All values, except avg_mapped_length, shown in millions')
```


### QC plots {.tabset}

Each of the QC plots we show on a per run mode basis, to see if there are any downstream differences based on the run mode variable settings.

#### 'Knee'-plot

```{r knee_plot, echo = F, fig.height=4, fig.width = 4*run_mode_n}
dge_summary <- tibble(run_mode = run_mode_names,
                      dge_summary_file = snakemake@input[paste0(run_mode, '.dge_summary')]) %>%
    unnest(dge_summary_file) %>%
    mutate(dat = map(dge_summary_file, ~ read_table2(.,
                                                     skip=7,
                                                     col_names = c('cell_bc', 'reads',
                                                                   'umis', 'genes')))) %>%
    unnest(dat) %>%
    select(-dge_summary_file) %>%
    mutate(pcr = reads/ umis) %>%
    group_by(run_mode)


read_counts <- dge_summary %>%
    select(run_mode, cell_bc, reads) %>%
    mutate(reads_cumsum = cumsum(reads),
           ix = 1:n())

read_counts %>%
    ggplot(aes(ix, reads_cumsum)) +
        geom_line() +
        ggtitle(paste0('Knee-plot, top  beads')) +
        labs(x='Beads sorted by number of reads', y='Cummulative sum of reads') +
        facet_wrap(~run_mode)
```

#### Umi-cutoff plots

```{r umi_cutoff_plot, echo = F, fig.width = 10, fig.height=6, dpi=300}
umi_cutoffs <- seq(10, 20000, 10)

cell_bc_len = nchar((dge_summary %$% cell_bc)[1])

dge_summary <- dge_summary %>%
    filter(nchar(cell_bc) == cell_bc_len) %>%
    mutate(quartile = ntile(1:n(), 4))

summarise_dge_summary <- function(umi_cutoff){
    dge_summary %>%
        filter(umis > umi_cutoff) %>%
        summarise(median_reads = median(reads),
                  median_umis = median(umis),
                  median_genes = median(genes),
                  median_pcr = median(pcr),
                  n_beads = n())
}

umi_cutoff_data <- tibble(umi_cutoffs = umi_cutoffs) %>%
    mutate(dat = map(umi_cutoffs, ~ summarise_dge_summary(.))) %>%
    unnest(dat)

p <- umi_cutoff_data %>%
    mutate(log10_n_beads = log10(n_beads)) %>%
    select(-n_beads) %>%
    gather('obs', 'value', -umi_cutoffs, -run_mode) %>%
    ggplot(aes(umi_cutoffs, value, color=obs, linetype = run_mode)) +
        geom_line() +
        scale_color_manual(values=summarised_clrs) +
        facet_wrap(~obs, ncol=3, scales='free') +
        scale_x_log10(breaks = c(10, 100, 1000, 10000)) +
        annotation_logticks(sides='b') +
        theme(strip.background=element_blank(), strip.text.x=element_blank(),
              text = element_text(size=18, face = 'plain'), 
              legend.title = element_blank(), legend.margin = margin(t=0.1, b=0.1, unit = 'cm'),
              legend.spacing = unit(0, 'cm')) +
        labs(color='', linetype='') +
        guides(colour = guide_legend(override.aes = list(size=5)))

grid.draw(shift_legend(p))
```

#### Histogram of metrics over beads

```{r plot_n_reads_bead_hist, echo = F, fig.width=10, fig.height=4*run_mode_n, dpi=300}
to_plot <- dge_summary %>%
    gather('obs', 'val', -cell_bc, -quartile, -run_mode)

min_difference <- to_plot %>% group_by(obs) %>%
    summarise(min_val = min(val,na.rm=T ),
              max_val = max(val,na.rm=T),
              difference = max_val - min_val) %>%
    summarise(min_difference = min(difference)) %$%
    min_difference

metric_plot <- function(metric, legend_pos='none'){
    pl <- to_plot %>%
        filter(obs == metric) %>%
        ggplot(aes(x = val, fill=obs)) +
            geom_histogram(bins=100) +
            scale_x_log10() +
            scale_fill_manual(values=clrs) +
            facet_grid(run_mode~obs, scales='free_y') +
            theme(legend.position = legend_pos,
                  strip.background.x=element_blank(), strip.text.x=element_blank())

    if(min_difference > 1){
        pl <- pl + 
            annotation_logticks(sides='b')
    }

    return(pl)
}
pl1 = metric_plot('reads')
pl2 = metric_plot('pcr')
pl3 = metric_plot('genes', 'bottom')
pl4 = metric_plot('umis')

plt_legend <- get_legend(pl3)

pl_metrics <- plot_grid(pl1, pl2, pl3 + theme(legend.position='none'),
                        pl4, align='vh', hjust=-1, labels="", nrow=2)

plot_grid(pl_metrics, plt_legend, ncol=1, rel_heights = c(1, .1))

#theme(legend.position = 'none', text = element_text(size=18, face='plain'))
```

#### Nucleotide distribution per beads

```{r plot_nucl_freq, echo = F, fig.height=3*run_mode_n, fig.width=12}
nucls <- dge_summary %$%
    cell_bc %>% strsplit("")

nucls <- dge_summary %>%
    select(cell_bc, quartile, run_mode) %>%
    bind_cols(tibble(nucl=nucls)) %>%
    unnest(nucl) %>%
    # group by run_mode and cell_bc, so each nt is on the correct pos
    group_by(run_mode, cell_bc) %>%
    mutate(pos = paste0('pos_', 100+1:n())) %>%
    group_by(run_mode, pos, nucl, quartile) %>%
    summarise(nucl_count = n()) %>%
    ungroup() %>%
    tidyr::complete(run_mode, pos, nucl, quartile, fill=list(nucl_count=0))

nucls %>%
    ggplot(aes(pos, nucl_count, fill = nucl)) +
        geom_bar(stat='identity', position='dodge') +
        scale_fill_manual(values=nucl_clrs) +
        scale_x_discrete(labels=seq(1, cell_bc_len, 1)) +
        facet_grid(run_mode~quartile) +
        ggtitle('Nucleotide distributions per nucleotide position and bead quartile')
```

#### Shannon entropy and string compression

```{r calc_shannon, echo = F}
calc_shannon_entropy <- function(barcode){
    counts <- strsplit(barcode, '')[[1]] %>% table
    len <- nchar(barcode) 

    (-1*sum(counts/len * log2(counts/len)))
}

calc_string_compression <- function(barcode){
    barcode_vector <- strsplit(barcode, '')[[1]]
    res <- rle(barcode_vector)
    compressed_barcode <- paste(res$values, res$lengths, collapse='', sep='')

    return(nchar(compressed_barcode))
}

theoretical <- c()
    
for(i in seq(1, dge_summary %>% nrow, 1)){
    theoretical[i] = paste(sample(c('A', 'C', 'T', 'G'), cell_bc_len, T), collapse='')
}

dge_summary <- dge_summary %>%
    add_column(theoretical_entropy = map(theoretical, ~ calc_shannon_entropy(.))) %>%
    mutate(exact_entropy = map(cell_bc, ~ calc_shannon_entropy(.))) %>%
    unnest(exact_entropy) %>%
    unnest(theoretical_entropy) %>%
    add_column(theoretical_string_compression = map(theoretical, ~ calc_string_compression(.))) %>%
    mutate(exact_string_compression = map(cell_bc, ~calc_string_compression(.))) %>%
    unnest(exact_string_compression) %>%
    unnest(theoretical_string_compression)
```

```{r plot_shannon, echo = F, fig.height=3*run_mode_n, fig.width=12}
dge_summary %>%
    dplyr::select(-reads, -umis, -genes, -pcr, -quartile) %>%
    gather('observation', 'value', -cell_bc, -run_mode) %>%
    # replace first _ with |, so we can separate later
    mutate(observation = str_replace(observation, '_', ' '),
           observation = str_replace(observation, '\\s', '|'),
           observation = str_replace(observation, ' ', '_')) %>%
    separate(observation, into = c('type', 'observation'), sep = '\\|') %>%
    ggplot(aes(value, fill = type)) +
        geom_histogram(bins=30, color='black', position='dodge') +
        scale_fill_manual(values=c(cpalette$grey, cpalette$orange)) +
        facet_grid(run_mode~observation, scales='free_x') +
        labs(fill='') +
        theme(legend.position = 'bottom', text = element_text(size=18, face='plain'))
```

