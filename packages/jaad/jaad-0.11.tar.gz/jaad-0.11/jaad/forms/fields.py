import json
from json import JSONDecodeError
from typing import Union

from django import forms
from django.core.exceptions import ValidationError as DjangoValidationError
from django.forms import Form as BaseForm, FileField
from django.http import QueryDict
from django_filters import widgets
from rest_framework.exceptions import ValidationError as RestFrameworkValidationError


class Form(BaseForm):
    def __init__(self, data=None, **kwargs):
        self.user = getattr(data, "current_user", None)

        super().__init__(data=data, **kwargs)
        self.data = self.parse_data(data)

    def parse_data(self, data: Union[QueryDict, None]):
        if data is None:
            return QueryDict("")

        current_user = getattr(data, "current_user", None)
        data = data.copy()
        data.current_user = current_user

        # base_fields, generated by FieldSetMetaclass, contains all the fields defined as attributes
        for field, field_definition in self.declared_fields.items():
            if field not in data and hasattr(field_definition, "default_value"):
                data[field] = field_definition.default_value

        return data

    def _clean_fields(self):
        for name, field in self.fields.items():
            # value_from_datadict() gets the data from the data dictionaries.
            # Each widget type knows how to retrieve its own data, because some
            # widgets split data over several HTML fields.
            if field.disabled:
                value = self.initial.get(name, field.initial)
            else:
                value = field.widget.value_from_datadict(
                    self.data, self.files, self.add_prefix(name)
                )
            try:
                if isinstance(field, FileField):
                    initial = self.initial.get(name, field.initial)
                    value = field.clean(value, initial)
                elif isinstance(field, UserSpecificField):
                    value = field.clean(value, user=self.user)
                else:
                    value = field.clean(value)
                self.cleaned_data[name] = value
                if hasattr(self, f"clean_{name}"):
                    value = getattr(self, f"clean_{name}")()
                    self.cleaned_data[name] = value
            except DjangoValidationError as e:
                self.add_error(name, e)


class UserSpecificField:
    def clean(self, value, user):
        """
        Validates the given value and returns its "cleaned" value as an
        appropriate Python object.

        Raises ValidationError for any errors.
        """
        value = self.to_python(value, user)
        self.validate(value)
        self.run_validators(value)
        return value


def set_field_default_value(field, default_value):
    field.default_value = default_value
    field.help_text = "{}<br />\n*Default to `{}`.*".format(
        field.help_text + " " if has_help_text(field) else "", default_value
    )


def has_help_text(field):
    return hasattr(field, "help_text") and field.help_text != ""


def add_description(field):
    if has_help_text(field):
        field.help_text = "{}<br />\n<br />\n{}".format(
            field.help_text, field.description
        )
    else:
        field.help_text = f"{field.description}"


class ChoiceField(forms.ChoiceField):
    @staticmethod
    def value_mapper(x):
        return x

    def __init__(self, *args, **kwargs):
        if "value_mapper" in kwargs:
            self.value_mapper = kwargs.pop("value_mapper")

        super().__init__(*args, **kwargs)
        self.description = "Can be {}.".format(
            " or ".join(
                f"`{value}` ({description})" for value, description in self.choices
            )
        )
        add_description(self)

    def clean(self, value):
        raw_value = super().clean(value)
        return self.value_mapper(raw_value)

    def to_python(self, value):
        if value is None:
            return None
        return super().to_python(value)


class DateField(forms.DateField):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Date (`{}`).\n<br />".format(
            "` or `".join(
                _date_format_to_human(input_format)
                for input_format in self.input_formats
            )
        )
        add_description(self)


class BooleanField(forms.BooleanField):
    json_field_type = "boolean"


class IntegerField(forms.IntegerField):
    json_field_type = "integer"


class FloatField(forms.FloatField):
    json_field_type = "number"


class CharField(forms.CharField):
    pass


def _date_format_to_human(date_format):
    return (
        date_format.replace("%Y", "YYYY")
        .replace("%m", "MM")
        .replace("%d", "DD")
        .replace("%H", "hh")
        .replace("%M", "mm")
        .replace("%S", "ss")
    )


class NullableCharField(forms.CharField):
    def to_python(self, value):
        if value is None:
            return None
        return super().to_python(value)


class CSVWidget(widgets.BaseCSVWidget):
    token = ","

    def format_value(self, value):
        return self.token.join(value)

    def value_from_datadict(self, data, files, name):
        return forms.Widget.value_from_datadict(self, data, files, name)

    def render(self, name, value, attrs=None):
        if not self._isiterable(value):
            value = [value]

        # if we have multiple values, we need to force render as a text input
        # (otherwise, the additional values are lost)
        surrogate = forms.TextInput()
        value = ",".join(str(v) if v is not None else "" for v in value)

        return surrogate.render(name, value, attrs)


class CommaSeparatedField(forms.Field):
    widget = CSVWidget
    sub_fields_type = None
    description = "Comma separated values."

    def __init__(self, *args, sub_fields_args=None, nullable=True, **kwargs):
        """
        :param sub_fields_args: dict of parameter to be passed to sub fields
        :param nullable: If False, return an empty list instead of None when field is not defined
        """
        if sub_fields_args is None:
            sub_fields_args = {}
        self.sub_fields_args = sub_fields_args
        self.nullable = nullable
        super().__init__(*args, **kwargs)
        add_description(self)

    def bound_data(self, data, initial):
        return ",".join(data)

    def to_python(self, data, cleaned=False):
        if data is None:
            if self.nullable:
                return (None, None) if cleaned else None
            else:
                return ([], []) if cleaned else []

        if data == "":
            return ([], []) if cleaned else []

        values = data.split(",")

        python_values = []
        cleaned_values = []
        for value in values:
            value_field = self.sub_fields_type(**self.sub_fields_args)
            try:
                python_values.append(value_field.to_python(value))
                if cleaned:
                    cleaned_values.append(value_field.clean(value))
            except DjangoValidationError as e:
                e.message = f"Error while validating one of the comma-separated value: {e.message}"  # noqa: B306
                raise e
            except RestFrameworkValidationError as e:
                e.detail = f"Error while validating one of the comma-separated value: {e.detail}"
                raise e

        if cleaned:
            return python_values, cleaned_values
        else:
            return python_values

    def clean(self, value):
        python_values, cleaned_values = self.to_python(value, cleaned=True)
        self.validate(python_values)
        self.run_validators(python_values)
        return cleaned_values

    def validate(self, value):
        if value in self.empty_values:
            super().validate(value)
        else:
            for sub_value in value:
                try:
                    self.sub_fields_type(**self.sub_fields_args).validate(sub_value)
                except (DjangoValidationError, RestFrameworkValidationError) as e:
                    e.error_list = [
                        "Error while validating the value '{}': {}".format(
                            sub_value, ",".join(message)
                        )
                        for message in e.error_list
                    ]
                    raise e

    def run_validators(self, value):
        super().run_validators(value)
        if value is not None:
            for sub_value in value:
                try:
                    self.sub_fields_type(**self.sub_fields_args).run_validators(
                        sub_value
                    )
                except (DjangoValidationError, RestFrameworkValidationError) as e:
                    e.error_list = [
                        "Error while validating the value '{}': {}".format(
                            sub_value, ",".join(message)
                        )
                        for message in e.error_list
                    ]
                    raise e


class RangeField(forms.Field):
    sub_fields_type = None

    def to_python(self, data):
        if data is None:
            return None

        values = data.split("-")

        start_as_string = values[0]
        end_as_string = values[1] if len(values) > 1 else values[0]
        start = self.sub_fields_type().to_python(start_as_string)
        stop = self.sub_fields_type().to_python(end_as_string)

        if start is None or stop is None:
            raise DjangoValidationError(f"Incorrect boundary in interval: {data}")

        if start > stop:
            raise DjangoValidationError(
                f"Bad interval: {stop} is lower than {start} in {data}"
            )

        return {"start": start, "stop": stop}


class IntegerRangeField(RangeField):
    sub_fields_type = forms.IntegerField


class DateRangeField(RangeField):
    sub_fields_type = DateField
    input_formats = [
        f"{input_format}` or `{input_format}-{input_format}"
        for input_format in sub_fields_type().input_formats
    ]


class CommaSeparatedCharField(CommaSeparatedField):
    sub_fields_type = forms.CharField


class CommaSeparatedIntegerField(CommaSeparatedField):
    sub_fields_type = forms.IntegerField


class CommaSeparatedChoiceField(CommaSeparatedField):
    sub_fields_type = ChoiceField

    def __init__(self, *args, **kwargs):
        self.description += " Each value must be {}.".format(
            " or ".join(
                f"`{choice}` ({desc})" if choice != desc else f"`{choice}`"
                for (choice, desc) in kwargs["sub_fields_args"]["choices"]
            )
        )
        super().__init__(*args, **kwargs)


class CommaSeparatedDecimalField(CommaSeparatedField):
    sub_fields_type = forms.FloatField

    def __init__(self, *args, **kwargs):
        self.description += " Each value must be a float" + (
            " between {} and {}".format(
                kwargs["sub_fields_args"]["min_value"],
                kwargs["sub_fields_args"]["max_value"],
            )
            if "sub_fields_args" in kwargs
            else ""
        )
        super().__init__(*args, **kwargs)


class CommaSeparatedDateRangeField(CommaSeparatedField):
    sub_fields_type = DateRangeField

    def __init__(self, *args, **kwargs):
        self.description += (
            " Each value must be a date or a range of dates (`{}`)".format(
                "` or `".join(
                    _date_format_to_human(input_format)
                    for input_format in self.sub_fields_type().input_formats
                )
            )
        )
        super().__init__(*args, **kwargs)


class CommaSeparatedIntegerRangeField(CommaSeparatedField):
    sub_fields_type = IntegerRangeField
    description = "Comma separated integers or range of integers (e.g. `7-14`)."


class StringField(forms.CharField):
    """
    Just an alias of CharField
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class DateTimeField(forms.DateTimeField):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Date (`{}`).\n<br />".format(
            "` or `".join(
                _date_format_to_human(input_format)
                for input_format in self.input_formats
            )
        )
        add_description(self)


class DateTimeRangeField(RangeField):
    sub_fields_type = DateTimeField
    input_formats = [
        f"{input_format}` or `{input_format}-{input_format}"
        for input_format in sub_fields_type().input_formats
    ]


class CommaSeparatedDateTimeRangeField(CommaSeparatedField):
    sub_fields_type = DateTimeRangeField

    def __init__(self, *args, **kwargs):
        self.description += (
            " Each value must be a datetime or a range of datetimes (`{}`)".format(
                "` or `".join(
                    _date_format_to_human(input_format)
                    for input_format in self.sub_fields_type().input_formats
                )
            )
        )
        super().__init__(*args, **kwargs)


class JsonField(forms.Field):
    description = "Expect a JSON."

    def __init__(self, *args, **kwargs):
        self.sub_fields_args = kwargs.pop("sub_fields_args", {})
        super().__init__(*args, **kwargs)
        add_description(self)

    def bound_data(self, data, initial):
        return ",".join(data)

    def to_python(self, data):
        if data is None:
            return None

        try:
            python_value = json.loads(data)
        except (JSONDecodeError, TypeError) as e:
            raise DjangoValidationError(
                "Error while parsing input string as a JSON: {}".format(
                    "; ".join(e.args)
                )
            )

        return python_value


class JsonArrayField(JsonField):
    description = "Expect a JSON array."

    def to_python(self, data):
        python_value = super().to_python(data)
        if data is not None and not isinstance(python_value, list):
            raise DjangoValidationError(f"Expecting element to be an array, got {data}")
        return python_value


class JsonObjectField(JsonField):
    description = "Expect a JSON object."

    def to_python(self, data):
        python_value = super().to_python(data)
        if data is not None and not isinstance(python_value, dict):
            raise DjangoValidationError(
                f"Expecting element to be an object, got {data}"
            )
        return python_value
