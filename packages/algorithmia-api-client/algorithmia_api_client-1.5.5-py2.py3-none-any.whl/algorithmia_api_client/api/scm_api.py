# coding: utf-8

"""
    Algorithmia Management APIs

    APIs for managing actions on the Algorithmia platform  # noqa: E501

    The version of the OpenAPI document: 1.5.0
    Contact: support@algorithmia.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from algorithmia_api_client.api_client import ApiClient
from algorithmia_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ScmApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_scm_connection(self, scm_id, **kwargs):  # noqa: E501
        """Create SCM authorized connection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_scm_connection(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_scm_connection_with_http_info(scm_id, **kwargs)  # noqa: E501

    def add_scm_connection_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Create SCM authorized connection  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_scm_connection_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_scm_connection" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `add_scm_connection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/token/connect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def complete_scm_authorization(self, code, scm_id, **kwargs):  # noqa: E501
        """Complete SCM authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Once a user has successfully authorized with the SCM's authorization server, said server will call this endpoint and supply the authorization code as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_scm_authorization(code, scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: OAuth authorization code which we will be exchanged for an access token. (required)
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.complete_scm_authorization_with_http_info(code, scm_id, **kwargs)  # noqa: E501

    def complete_scm_authorization_with_http_info(self, code, scm_id, **kwargs):  # noqa: E501
        """Complete SCM authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Once a user has successfully authorized with the SCM's authorization server, said server will call this endpoint and supply the authorization code as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_scm_authorization_with_http_info(code, scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: OAuth authorization code which we will be exchanged for an access token. (required)
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'code',
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method complete_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in local_var_params or  # noqa: E501
                                                        local_var_params['code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `code` when calling `complete_scm_authorization`")  # noqa: E501
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `complete_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/oauth/finish', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_scm(self, scm_configuration_request_dto, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm(scm_configuration_request_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ScmConfigurationRequestDto scm_configuration_request_dto: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConfigurationResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_scm_with_http_info(scm_configuration_request_dto, **kwargs)  # noqa: E501

    def create_scm_with_http_info(self, scm_configuration_request_dto, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm_with_http_info(scm_configuration_request_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ScmConfigurationRequestDto scm_configuration_request_dto: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConfigurationResponseDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_configuration_request_dto'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_configuration_request_dto' is set
        if self.api_client.client_side_validation and ('scm_configuration_request_dto' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_configuration_request_dto'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_configuration_request_dto` when calling `create_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'scm_configuration_request_dto' in local_var_params:
            body_params = local_var_params['scm_configuration_request_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConfigurationResponseDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_scm(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def delete_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `delete_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_scm_connection_status(self, username, algoname, **kwargs):  # noqa: E501
        """Get algorithm SCM connection status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_scm_connection_status(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param str algoname: Algorithm name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConnectionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_scm_connection_status_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def get_algorithm_scm_connection_status_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Get algorithm SCM connection status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_scm_connection_status_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param str algoname: Algorithm name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConnectionStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_scm_connection_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_scm_connection_status`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_scm_connection_status`")  # noqa: E501

        if self.api_client.client_side_validation and ('username' in local_var_params and  # noqa: E501
                                                        len(local_var_params['username']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_scm_connection_status`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_scm_connection_status`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/algorithms/{username}/{algoname}/scm/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConnectionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scm(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM information  # noqa: E501

        Retrieve information about a single SCM (source control management system) by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConfigurationResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def get_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM information  # noqa: E501

        Retrieve information about a single SCM (source control management system) by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConfigurationResponseDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `get_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConfigurationResponseDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scm_status(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM authorization status  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM (source control management system) in question, this endpoint describes the SCM username that represents the user, as well as any organizations they have access to. If the calling user has not completed the authorization flow, we return an `authorization_status` of `unauthorized`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_status(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmUserOAuthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_scm_status_with_http_info(scm_id, **kwargs)  # noqa: E501

    def get_scm_status_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM authorization status  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM (source control management system) in question, this endpoint describes the SCM username that represents the user, as well as any organizations they have access to. If the calling user has not completed the authorization flow, we return an `authorization_status` of `unauthorized`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_status_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmUserOAuthStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scm_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `get_scm_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/oauth/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmUserOAuthStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def initiate_scm_authorization(self, scm_id, **kwargs):  # noqa: E501
        """Initiate SCM authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Allows a user to begin the OAuth authorization flow for a given SCM (source control management system), thereby allowing Algorithmia to access any necessary SCM resources on their behalf, such as repositories, deploy keys, and webhooks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initiate_scm_authorization(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.initiate_scm_authorization_with_http_info(scm_id, **kwargs)  # noqa: E501

    def initiate_scm_authorization_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Initiate SCM authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Allows a user to begin the OAuth authorization flow for a given SCM (source control management system), thereby allowing Algorithmia to access any necessary SCM resources on their behalf, such as repositories, deploy keys, and webhooks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initiate_scm_authorization_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method initiate_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `initiate_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/oauth/start', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_scms(self, **kwargs):  # noqa: E501
        """List SCMs  # noqa: E501

        List SCMs (source control management systems) configured for the Algorithmia instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scms(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_scms_with_http_info(**kwargs)  # noqa: E501

    def list_scms_with_http_info(self, **kwargs):  # noqa: E501
        """List SCMs  # noqa: E501

        List SCMs (source control management systems) configured for the Algorithmia instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2002, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_scms" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receive_algorithm_by_id_scm_repository_event(self, algorithm_id, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_algorithm_by_id_scm_repository_event(algorithm_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param object body: Contains information for the event that triggered this webhook (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.receive_algorithm_by_id_scm_repository_event_with_http_info(algorithm_id, body, **kwargs)  # noqa: E501

    def receive_algorithm_by_id_scm_repository_event_with_http_info(self, algorithm_id, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_algorithm_by_id_scm_repository_event_with_http_info(algorithm_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param object body: Contains information for the event that triggered this webhook (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse202, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receive_algorithm_by_id_scm_repository_event" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `receive_algorithm_by_id_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `receive_algorithm_by_id_scm_repository_event`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `receive_algorithm_by_id_scm_repository_event`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['GithubAuth', 'GithubEventIdentification', 'XBitbucketKey', 'XGitlabEvent']  # noqa: E501

        return self.api_client.call_api(
            '/v1/algorithms/{algorithmId}/scm/webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receive_scm_repository_event(self, username, algoname, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_scm_repository_event(username, algoname, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param str algoname: Algorithm name (required)
        :param object body: Contains information for the event that triggered this webhook (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.receive_scm_repository_event_with_http_info(username, algoname, body, **kwargs)  # noqa: E501

    def receive_scm_repository_event_with_http_info(self, username, algoname, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_scm_repository_event_with_http_info(username, algoname, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param str algoname: Algorithm name (required)
        :param object body: Contains information for the event that triggered this webhook (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse202, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receive_scm_repository_event" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `receive_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `receive_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `receive_scm_repository_event`")  # noqa: E501

        if self.api_client.client_side_validation and ('username' in local_var_params and  # noqa: E501
                                                        len(local_var_params['username']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `receive_scm_repository_event`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `receive_scm_repository_event`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['GithubAuth', 'GithubEventIdentification', 'XBitbucketKey', 'XGitlabEvent']  # noqa: E501

        return self.api_client.call_api(
            '/v1/algorithms/{username}/{algoname}/scm/webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_scm_authorization(self, scm_id, **kwargs):  # noqa: E501
        """Revoke SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM (source control management system) in question, this endpoint prompts us to invalidate and discard said access token. After this has occurred, all algorithms created by the user will continue to function, but they will no longer be able to create algorithms backed by the SCM.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scm_authorization(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_scm_authorization_with_http_info(scm_id, **kwargs)  # noqa: E501

    def revoke_scm_authorization_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Revoke SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM (source control management system) in question, this endpoint prompts us to invalidate and discard said access token. After this has occurred, all algorithms created by the user will continue to function, but they will no longer be able to create algorithms backed by the SCM.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scm_authorization_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `revoke_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/oauth/revoke', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scm_token_status(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM authorization status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scm_token_status(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmUserOAuthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scm_token_status_with_http_info(scm_id, **kwargs)  # noqa: E501

    def scm_token_status_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM authorization status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scm_token_status_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmUserOAuthStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scm_token_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `scm_token_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/scms/{scmId}/token/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmUserOAuthStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_scm(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_default_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def set_default_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `set_default_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_scm(self, scm_id, scm_update_request, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm(scm_id, scm_update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param ScmUpdateRequest scm_update_request: The enabled property or the scmUrls may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. You must pass all 3 valid scmUrls or none (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConfigurationResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_scm_with_http_info(scm_id, scm_update_request, **kwargs)  # noqa: E501

    def update_scm_with_http_info(self, scm_id, scm_update_request, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm_with_http_info(scm_id, scm_update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param ScmUpdateRequest scm_update_request: The enabled property or the scmUrls may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. You must pass all 3 valid scmUrls or none (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConfigurationResponseDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id',
            'scm_update_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `update_scm`")  # noqa: E501
        # verify the required parameter 'scm_update_request' is set
        if self.api_client.client_side_validation and ('scm_update_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_update_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_update_request` when calling `update_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'scm_update_request' in local_var_params:
            body_params = local_var_params['scm_update_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConfigurationResponseDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
