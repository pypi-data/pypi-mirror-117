# coding: utf-8

"""
    Algorithmia Management APIs

    APIs for managing actions on the Algorithmia platform  # noqa: E501

    The version of the OpenAPI document: 1.5.0
    Contact: support@algorithmia.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from algorithmia_api_client.api_client import ApiClient
from algorithmia_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class AdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def admin_list_secret_providers(self, **kwargs):  # noqa: E501
        """List secret providers as an admin user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_list_secret_providers(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ProviderInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_list_secret_providers_with_http_info(**kwargs)  # noqa: E501

    def admin_list_secret_providers_with_http_info(self, **kwargs):  # noqa: E501
        """List secret providers as an admin user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_list_secret_providers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ProviderInfo], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_list_secret_providers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/secret-provider', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProviderInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_secret_provider_for_jar(self, provider_id, **kwargs):  # noqa: E501
        """Check if a .jar file has been uploaded for a secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_secret_provider_for_jar(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_secret_provider_for_jar_with_http_info(provider_id, **kwargs)  # noqa: E501

    def check_secret_provider_for_jar_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Check if a .jar file has been uploaded for a secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_secret_provider_for_jar_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_secret_provider_for_jar" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `check_secret_provider_for_jar`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `check_secret_provider_for_jar`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/plugins/secret-provider/{providerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_organization_host_information(self, org_name, create_organization_host_information, **kwargs):  # noqa: E501
        """Create new Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization_host_information(org_name, create_organization_host_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param CreateOrganizationHostInformation create_organization_host_information: Request to create new Organization Host Information mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_organization_host_information_with_http_info(org_name, create_organization_host_information, **kwargs)  # noqa: E501

    def create_organization_host_information_with_http_info(self, org_name, create_organization_host_information, **kwargs):  # noqa: E501
        """Create new Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization_host_information_with_http_info(org_name, create_organization_host_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param CreateOrganizationHostInformation create_organization_host_information: Request to create new Organization Host Information mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'create_organization_host_information'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_organization_host_information" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `create_organization_host_information`")  # noqa: E501
        # verify the required parameter 'create_organization_host_information' is set
        if self.api_client.client_side_validation and ('create_organization_host_information' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_host_information'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_host_information` when calling `create_organization_host_information`")  # noqa: E501

        if self.api_client.client_side_validation and ('org_name' in local_var_params and  # noqa: E501
                                                        len(local_var_params['org_name']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `create_organization_host_information`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `create_organization_host_information`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_host_information' in local_var_params:
            body_params = local_var_params['create_organization_host_information']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/organization_host_information/{orgName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_reservation(self, reservation_create, **kwargs):  # noqa: E501
        """Create a new reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_reservation(reservation_create, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ReservationCreate reservation_create: Create a reservation for an algorithm (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_reservation_with_http_info(reservation_create, **kwargs)  # noqa: E501

    def create_reservation_with_http_info(self, reservation_create, **kwargs):  # noqa: E501
        """Create a new reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_reservation_with_http_info(reservation_create, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ReservationCreate reservation_create: Create a reservation for an algorithm (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'reservation_create'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_reservation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'reservation_create' is set
        if self.api_client.client_side_validation and ('reservation_create' not in local_var_params or  # noqa: E501
                                                        local_var_params['reservation_create'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reservation_create` when calling `create_reservation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reservation_create' in local_var_params:
            body_params = local_var_params['reservation_create']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/reservations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_scm(self, scm_configuration_request_dto, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm(scm_configuration_request_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ScmConfigurationRequestDto scm_configuration_request_dto: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConfigurationResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_scm_with_http_info(scm_configuration_request_dto, **kwargs)  # noqa: E501

    def create_scm_with_http_info(self, scm_configuration_request_dto, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm_with_http_info(scm_configuration_request_dto, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ScmConfigurationRequestDto scm_configuration_request_dto: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConfigurationResponseDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_configuration_request_dto'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_configuration_request_dto' is set
        if self.api_client.client_side_validation and ('scm_configuration_request_dto' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_configuration_request_dto'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_configuration_request_dto` when calling `create_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'scm_configuration_request_dto' in local_var_params:
            body_params = local_var_params['scm_configuration_request_dto']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConfigurationResponseDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_secret_provider(self, **kwargs):  # noqa: E501
        """Create a new secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_secret_provider(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SecretProviderRequest secret_provider_request: Request for creating and updating secret providers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProviderInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_secret_provider_with_http_info(**kwargs)  # noqa: E501

    def create_secret_provider_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_secret_provider_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SecretProviderRequest secret_provider_request: Request for creating and updating secret providers
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProviderInfo, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'secret_provider_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_secret_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_provider_request' in local_var_params:
            body_params = local_var_params['secret_provider_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/secret-provider', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProviderInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete(self, org_name, **kwargs):  # noqa: E501
        """Deletes the Organization Host Information for org named  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_with_http_info(org_name, **kwargs)  # noqa: E501

    def delete_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """Deletes the Organization Host Information for org named  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `delete`")  # noqa: E501

        if self.api_client.client_side_validation and ('org_name' in local_var_params and  # noqa: E501
                                                        len(local_var_params['org_name']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `delete`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `delete`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/organization_host_information/{orgName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_provider(self, provider_id, **kwargs):  # noqa: E501
        """Delete a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_provider(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_provider_with_http_info(provider_id, **kwargs)  # noqa: E501

    def delete_provider_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Delete a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_provider_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `delete_provider`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `delete_provider`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/secret-provider/{providerId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_reservation(self, reservation_id, **kwargs):  # noqa: E501
        """Delete a reservation by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_reservation(reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str reservation_id: The reservation to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_reservation_with_http_info(reservation_id, **kwargs)  # noqa: E501

    def delete_reservation_with_http_info(self, reservation_id, **kwargs):  # noqa: E501
        """Delete a reservation by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_reservation_with_http_info(reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str reservation_id: The reservation to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'reservation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_reservation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'reservation_id' is set
        if self.api_client.client_side_validation and ('reservation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['reservation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reservation_id` when calling `delete_reservation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in local_var_params:
            path_params['reservation_id'] = local_var_params['reservation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/reservations/{reservation_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_scm(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def delete_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `delete_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def feature_flag_list(self, **kwargs):  # noqa: E501
        """Lists all available feature flags returned for authorized users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feature_flag_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[FeatureFlag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.feature_flag_list_with_http_info(**kwargs)  # noqa: E501

    def feature_flag_list_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all available feature flags returned for authorized users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.feature_flag_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[FeatureFlag], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method feature_flag_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/features', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeatureFlag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_usage_result(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get algorithm usage information  # noqa: E501

        Returns usage information for a given date range. Paginated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_result(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AlgorithmUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_usage_result_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_algorithm_usage_result_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get algorithm usage information  # noqa: E501

        Returns usage information for a given date range. Paginated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_result_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AlgorithmUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_usage_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_algorithm_usage_result`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_algorithm_usage_result`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_algorithm_usage_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/usage/algorithms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_by_org_name(self, org_name, **kwargs):  # noqa: E501
        """Get Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_org_name(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationHostInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_by_org_name_with_http_info(org_name, **kwargs)  # noqa: E501

    def get_by_org_name_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """Get Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_org_name_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationHostInformation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_by_org_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `get_by_org_name`")  # noqa: E501

        if self.api_client.client_side_validation and ('org_name' in local_var_params and  # noqa: E501
                                                        len(local_var_params['org_name']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `get_by_org_name`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `get_by_org_name`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/organization_host_information/{orgName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationHostInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_full_usage(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get usage information  # noqa: E501

        Returns usage information for a given date range. Paginated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_usage(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FullUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_full_usage_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_full_usage_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get usage information  # noqa: E501

        Returns usage information for a given date range. Paginated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_usage_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FullUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_full_usage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_full_usage`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_full_usage`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_full_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FullUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_legacy_algorithmi_usage_result(self, **kwargs):  # noqa: E501
        """Get legacy algorithm usage information  # noqa: E501

        Returns usage information on legacy algorithms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_legacy_algorithmi_usage_result(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LegacyAlgorithmUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_legacy_algorithmi_usage_result_with_http_info(**kwargs)  # noqa: E501

    def get_legacy_algorithmi_usage_result_with_http_info(self, **kwargs):  # noqa: E501
        """Get legacy algorithm usage information  # noqa: E501

        Returns usage information on legacy algorithms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_legacy_algorithmi_usage_result_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LegacyAlgorithmUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_legacy_algorithmi_usage_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/legacy-algorithms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LegacyAlgorithmUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_reservations(self, **kwargs):  # noqa: E501
        """Get current reservations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Reservation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_reservations_with_http_info(**kwargs)  # noqa: E501

    def get_reservations_with_http_info(self, **kwargs):  # noqa: E501
        """Get current reservations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Reservation], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reservations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/reservations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Reservation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_secret_provider(self, provider_id, **kwargs):  # noqa: E501
        """Get a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_secret_provider(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProviderInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_secret_provider_with_http_info(provider_id, **kwargs)  # noqa: E501

    def get_secret_provider_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Get a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_secret_provider_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProviderInfo, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_secret_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `get_secret_provider`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `get_secret_provider`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/secret-provider/{providerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProviderInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_usage_result(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get usage information grouped by user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_usage_result(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UserUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_usage_result_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_user_usage_result_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """Get usage information grouped by user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_usage_result_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime start_date: start date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param datetime end_date: end date of query range in UTC format (2021-03-22T00:00:00.000Z) (required)
        :param int page_size: maximum number of results to return in one query (required)
        :param list[str] user: user or organization names
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UserUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_usage_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_user_usage_result`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_user_usage_result`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_user_usage_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/usage/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_api_key(self, username, **kwargs):  # noqa: E501
        """Add a specific API key for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_api_key(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.import_api_key_with_http_info(username, **kwargs)  # noqa: E501

    def import_api_key_with_http_info(self, username, **kwargs):  # noqa: E501
        """Add a specific API key for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_api_key_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The username of the user or organization (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApiKey, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_api_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `import_api_key`")  # noqa: E501

        if self.api_client.client_side_validation and ('username' in local_var_params and  # noqa: E501
                                                        len(local_var_params['username']) > 30):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `import_api_key`, length must be less than or equal to `30`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `import_api_key`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/users/{username}/keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_scm(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_default_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def set_default_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `set_default_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_secret_provider(self, provider_id, **kwargs):  # noqa: E501
        """Make a secret provider the default secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_secret_provider(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_default_secret_provider_with_http_info(provider_id, **kwargs)  # noqa: E501

    def set_default_secret_provider_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Make a secret provider the default secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_secret_provider_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_secret_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `set_default_secret_provider`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `set_default_secret_provider`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/plugins/secret-provider/{providerId}/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def toggle_feature_flag(self, feature_name, feature_flag_toggle, **kwargs):  # noqa: E501
        """Enabled/disabled a feature flag globally  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_feature_flag(feature_name, feature_flag_toggle, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str feature_name: The name of the feature flag (required)
        :param FeatureFlagToggle feature_flag_toggle: Feature flag toggle (required)
        :param str username: The username of the user or organization
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.toggle_feature_flag_with_http_info(feature_name, feature_flag_toggle, **kwargs)  # noqa: E501

    def toggle_feature_flag_with_http_info(self, feature_name, feature_flag_toggle, **kwargs):  # noqa: E501
        """Enabled/disabled a feature flag globally  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_feature_flag_with_http_info(feature_name, feature_flag_toggle, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str feature_name: The name of the feature flag (required)
        :param FeatureFlagToggle feature_flag_toggle: Feature flag toggle (required)
        :param str username: The username of the user or organization
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'feature_name',
            'feature_flag_toggle',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toggle_feature_flag" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'feature_name' is set
        if self.api_client.client_side_validation and ('feature_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_name` when calling `toggle_feature_flag`")  # noqa: E501
        # verify the required parameter 'feature_flag_toggle' is set
        if self.api_client.client_side_validation and ('feature_flag_toggle' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_flag_toggle'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_flag_toggle` when calling `toggle_feature_flag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'feature_name' in local_var_params:
            path_params['featureName'] = local_var_params['feature_name']  # noqa: E501

        query_params = []
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'feature_flag_toggle' in local_var_params:
            body_params = local_var_params['feature_flag_toggle']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/features/{featureName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update(self, organization_host_information, **kwargs):  # noqa: E501
        """Update existing Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update(organization_host_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationHostInformation organization_host_information: Request with Organization Host Information (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_with_http_info(organization_host_information, **kwargs)  # noqa: E501

    def update_with_http_info(self, organization_host_information, **kwargs):  # noqa: E501
        """Update existing Organization Host Information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_with_http_info(organization_host_information, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationHostInformation organization_host_information: Request with Organization Host Information (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_host_information'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_host_information' is set
        if self.api_client.client_side_validation and ('organization_host_information' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_host_information'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_host_information` when calling `update`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_host_information' in local_var_params:
            body_params = local_var_params['organization_host_information']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/organization_host_information', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_provider(self, provider_id, **kwargs):  # noqa: E501
        """Update a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_provider(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param SecretProviderRequest secret_provider_request: Request for creating and updating secret providers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProviderInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_provider_with_http_info(provider_id, **kwargs)  # noqa: E501

    def update_provider_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Update a secret provider by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_provider_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param SecretProviderRequest secret_provider_request: Request for creating and updating secret providers
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProviderInfo, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id',
            'secret_provider_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `update_provider`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `update_provider`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_provider_request' in local_var_params:
            body_params = local_var_params['secret_provider_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/secret-provider/{providerId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProviderInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_scm(self, scm_id, scm_update_request, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm(scm_id, scm_update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param ScmUpdateRequest scm_update_request: The enabled property or the scmUrls may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. You must pass all 3 valid scmUrls or none (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConfigurationResponseDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_scm_with_http_info(scm_id, scm_update_request, **kwargs)  # noqa: E501

    def update_scm_with_http_info(self, scm_id, scm_update_request, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm_with_http_info(scm_id, scm_update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param ScmUpdateRequest scm_update_request: The enabled property or the scmUrls may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. You must pass all 3 valid scmUrls or none (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConfigurationResponseDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id',
            'scm_update_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `update_scm`")  # noqa: E501
        # verify the required parameter 'scm_update_request' is set
        if self.api_client.client_side_validation and ('scm_update_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_update_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_update_request` when calling `update_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'scm_update_request' in local_var_params:
            body_params = local_var_params['scm_update_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/scms/{scmId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConfigurationResponseDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_jar_for_secret_provider(self, provider_id, **kwargs):  # noqa: E501
        """Upload a .jar file for the target secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_jar_for_secret_provider(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_jar_for_secret_provider_with_http_info(provider_id, **kwargs)  # noqa: E501

    def upload_jar_for_secret_provider_with_http_info(self, provider_id, **kwargs):  # noqa: E501
        """Upload a .jar file for the target secret provider  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_jar_for_secret_provider_with_http_info(provider_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str provider_id: Secret UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'provider_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_jar_for_secret_provider" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'provider_id' is set
        if self.api_client.client_side_validation and ('provider_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['provider_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `provider_id` when calling `upload_jar_for_secret_provider`")  # noqa: E501

        if self.api_client.client_side_validation and 'provider_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['provider_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `provider_id` when calling `upload_jar_for_secret_provider`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'provider_id' in local_var_params:
            path_params['providerId'] = local_var_params['provider_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/admin/plugins/secret-provider/{providerId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
