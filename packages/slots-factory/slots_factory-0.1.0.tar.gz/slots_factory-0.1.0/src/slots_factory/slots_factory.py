from functools import update_wrapper
from types import (
    FunctionType
)

from slots_factory.tools.SlotsFactoryTools import (
    _slots_factory_hash,
    _slots_factory_setattrs,
)

from .initializers import (
    wrapped_defaults,
    wrapped_functions,
    wrapped_not_frozen,
    wrapped_generic,
    wrapped_slim
)

from .object_model_methods import (
    _frozen,
    _ordering_methods,
    __repr__,
    __len__,
    __eq__,
    __hash__,
    __iter__
)


TYPEDEF_DICT_KEYS = {
    '__module__', '__annotations__', '__doc__', '__dict__', '__weakref__'
}


def slots_from_type(type_, **kwargs):
    """Convenience function. Takes a type and kwargs, and instantiates the type
    with kwargs assigned to corresponding attributes.

    :param type_: type as derived from type_factory()
    :type type_: type
    :return: instance of the type, with assigned attributes
    :rtype: SlotsObject
    """
    instance = type_()
    _slots_factory_setattrs(instance, kwargs, False)
    return instance


def slots_from_dict(attrs={}, _name="SlotsObject", **kwargs):
    """function that returns a Python Python instance w/ __slots__ from a dict,
    allows for same kwargs as dataslots.
    
    :param attrs: dictionary template for setting attr values on returned
    instance
    :param _name: name of returned object
    :param **kwargs: options for type definition, mirrors those of @dataslots

    :return: SlotsObject instance
    :rtype: SlotsObject
    """
    if not kwargs.get("order"):
        kwargs['order'] = attrs.keys()
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        fast_slots.__dict__[_name] = type_factory(attrs.keys(), _name, **kwargs)
    return fast_slots(_name, **attrs) 


def type_factory(args, _name="Slots_Object", **kwargs):
    """function that returns a new Python type w/ __slots__, and other dunder
    methods if specified.

    :param _name: name of the new type
    :type _name: str
    :param args: iterable (list, tuple) of strings that correspond to the
    attributes of the objects
    :type args: Iter[str, str...]

    :return: type definition defined by function arguments
    :rtype: type
    """
    methods = {
        "__slots__": args,
        "__iter__": __iter__,
        "__len__": __len__,
        "__eq__": __eq__,
        "__hash__": __hash__,
        "__repr__": __repr__
    }

    frozen = kwargs.get("frozen")
    if frozen:
        methods.update({"__setattr__": _frozen, "__delattr__": _frozen})

    _order = kwargs.get("order")
    if _order:
        methods.update(_ordering_methods(args, _order))

    _docs = kwargs.get("__doc__")
    if _docs:
        methods.update({"__doc__": _docs})

    _properties = kwargs.get("_properties")
    if _properties:
        methods.update(**_properties)

    return type(_name, (), methods)


def slots_factory(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    id_ = _slots_factory_hash(_name, kwargs)
    type_ = slots_factory.__dict__.get(id_)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        slots_factory.__dict__[id_] = type_
    instance = type_()
    _slots_factory_setattrs(instance, kwargs, False)
    return instance


def fast_slots(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__. Only uses
    name for caching, and makes a new object type when AttributeError is raised.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        fast_slots.__dict__[_name] = type_
    try:
        instance = type_()
        _slots_factory_setattrs(instance, kwargs, True)
        return instance
    except AttributeError:
        del fast_slots.__dict__[_name]
        return fast_slots(_name, **kwargs)


def dataslots(_cls=None, **ds_kwargs):
    """provides a decorator for ingesting type definitions derived from `class`
    and returning a retyped definition which contains __slots__.

    :param _cls: object to be emulated
    :type _cls: type

    :param frozen: optional flag for ensuring data is immutable
    :type frozen: bool

    :return: wrapper functions
    :rtype: function
    """

    def wrapper(f):
        _attrs, _functions, _properties = {}, {}, {}
        for collection in (f.__annotations__, f.__dict__):
            for k, v in collection.items():
                if k in TYPEDEF_DICT_KEYS:
                    continue
                if isinstance(v, FunctionType):
                    _functions[k] = v
                elif isinstance(v, property):
                    _properties[k] = v
                else:
                    _attrs[k] = v

        _keys = _attrs.keys()
        _ds_kwargs = {
            "__doc__": f.__doc__,
            "_properties": _properties,
            **wrapper.__dict__["ds_kwargs"],
        }

        _type = type_factory(
            list(_keys) + list(_functions.keys()), f.__name__, **_ds_kwargs
        )

        _defaults = {
            key: getattr(f, key) for key in _keys if hasattr(f, key)
        }

        if not wrapper.__dict__["ds_kwargs"].get("frozen", False):
            if not _defaults and not _functions:
                wrapped = wrapped_slim()
            elif not _functions:
                wrapped = wrapped_defaults()
            elif not _defaults:
                wrapped = wrapped_functions()
            else:
                wrapped = wrapped_not_frozen()
        else:
            wrapped = wrapped_generic()

        wrapped.__dict__["_type"] = _type
        wrapped.__dict__["_defaults"] = _defaults
        wrapped.__dict__["_functions"] = _functions

        return update_wrapper(wrapped, f)

    wrapper.__dict__["ds_kwargs"] = ds_kwargs
    if _cls is None:
        return wrapper
    return wrapper(_cls)
dataslots.__dict__["from_dict"] = slots_from_dict
