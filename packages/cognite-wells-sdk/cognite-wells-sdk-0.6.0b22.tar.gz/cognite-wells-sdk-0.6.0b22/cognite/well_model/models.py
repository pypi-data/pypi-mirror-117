# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Dict, List, Optional

from pydantic import Extra, Field

from cognite.well_model.base_model import WellsBaseModel


class DoubleWithUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float
    unit: str = Field(..., example="meter")


class StringItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[str]


class DateRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[date] = None
    max: Optional[date] = None


class DistanceUnitEnum(Enum):
    meter = "meter"
    foot = "foot"
    inch = "inch"
    yard = "yard"


class AngleUnitEnum(Enum):
    degree = "degree"
    radian = "radian"


class WeightUnitEnum(Enum):
    kilogram = "kilogram"
    pound = "pound"


class DoubleRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[float] = None
    max: Optional[float] = None


class DoubleArrayWithUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    values: List[float]
    unit: str


class Identifier(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    asset_external_id: Optional[str] = Field(None, alias="assetExternalId")


class IdentifierItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Identifier] = Field(..., max_items=1000, min_items=1)


class Item(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str


class NameItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Item]


class WellMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    country: List[str]
    quadrant: List[str]
    block: List[str]
    field: List[str]
    operator: List[str]
    spud_date: List[str] = Field(..., alias="spudDate")
    license: List[str]
    well_type: List[str] = Field(..., alias="wellType")
    water_depth: List[str] = Field(..., alias="waterDepth")
    wellhead: List[str]


class Wellhead(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    x: float = Field(..., example=1)
    y: float = Field(..., example=1)
    crs: str = Field(..., example="Example")


class WellboreMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    datum: List[str]


class SpudDateLimits(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[date] = None
    max: Optional[date] = None


class WaterDepthLimits(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[DoubleWithUnit] = None
    max: Optional[DoubleWithUnit] = None


class ContainsAllOrAny(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[str]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[str]] = Field(None, alias="containsAny", description="match on any of the strings")


class ContainsAllOrAnyInt(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[int]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[int]] = Field(None, alias="containsAny", description="match on any of the strings")


class ColumnAndUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External id of the sequence column", example="MD"
    )
    unit: str = Field(..., description="Unit for the measurement type", example="meter")


class MeasurementType(Enum):
    gamma_ray = "gammaRay"
    caliper = "caliper"
    density = "density"
    geomechanics = "geomechanics"
    ppfg = "ppfg"
    resistivity_deep = "resistivityDeep"
    resistivity_medium = "resistivityMedium"
    neutron = "neutron"
    fit = "fit"
    lot = "lot"
    acoustics = "acoustics"
    borehole_properties = "boreholeProperties"
    drilling_parameters = "drillingParameters"
    flag = "flag"
    fluid_properties = "fluidProperties"
    geophysical_synthetics = "geophysicalSynthetics"
    mud_logs = "mudLogs"
    nuclear_magnetc_resonance = "nuclearMagnetcResonance"
    permeability = "permeability"
    petrophysical_parameters = "petrophysicalParameters"
    photoelectric_factor = "photoelectricFactor"
    porosity = "porosity"
    pressure = "pressure"
    reference = "reference"
    resistivity = "resistivity"
    salinity = "salinity"
    saturation = "saturation"
    temperature = "temperature"
    volume_fraction = "volumeFraction"


class Item1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Optional[MeasurementType] = None


class MeasurementTypeItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Item1]


class TrajectoryIngestionRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: float = Field(..., alias="measuredDepth")
    inclination: float
    azimuth: float
    dogleg_severity: Optional[float] = Field(None, alias="doglegSeverity")


class DepthRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_depth: Optional[float] = Field(None, alias="minDepth")
    max_depth: Optional[float] = Field(None, alias="maxDepth")
    unit: DistanceUnitEnum


class AngleRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_angle: Optional[float] = Field(None, alias="minAngle")
    max_angle: Optional[float] = Field(None, alias="maxAngle")
    unit: AngleUnitEnum


class TrajectoryDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth_range: Optional[DepthRange] = Field(None, alias="measuredDepthRange")
    true_vertical_depth_range: Optional[DepthRange] = Field(None, alias="trueVerticalDepthRange")


class TrajectoryDataRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    true_vertical_depth: float = Field(..., alias="trueVerticalDepth")
    measured_depth: float = Field(..., alias="measuredDepth")
    northing: float
    easting: float
    azimuth: float
    inclination: float
    dogleg_severity: Optional[float] = Field(None, alias="doglegSeverity")


class TrajectoryDataRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryDataRequest]


class CasingAssembly(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_inside_diameter: DoubleWithUnit = Field(..., alias="minInsideDiameter")
    min_outside_diameter: DoubleWithUnit = Field(..., alias="minOutsideDiameter")
    max_outside_diameter: DoubleWithUnit = Field(..., alias="maxOutsideDiameter")
    original_measured_depth_top: DoubleWithUnit = Field(..., alias="originalMeasuredDepthTop")
    original_measured_depth_base: DoubleWithUnit = Field(..., alias="originalMeasuredDepthBase")
    type: Optional[str] = None
    report_description: Optional[str] = Field(None, alias="reportDescription")


class Search(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    query: str = Field(..., description="Fuzzy search name and description")


class TrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    max_measured_depth: Optional[DepthRange] = Field(None, alias="maxMeasuredDepth")
    max_true_vertical_depth: Optional[DepthRange] = Field(None, alias="maxTrueVerticalDepth")
    max_inclination: Optional[AngleRange] = Field(None, alias="maxInclination")


class PolygonFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    geometry: str = Field(..., example="POINT (1.42 1.35)")
    crs: str = Field(..., example="EPSG:4326")
    geometry_type: Optional[str] = Field(None, alias="geometryType", example="WKT")


class MeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: MeasurementType = Field(..., alias="measurementType")
    min_depth: Optional[float] = Field(
        None,
        alias="minDepth",
        description="Not implemented in the first version. Allows to filter on measurements that have values below this depth",
        example=1000,
    )
    max_depth: Optional[float] = Field(
        None,
        alias="maxDepth",
        description="Not implemented in the first version. Allows to filter on measurements that have values above this depth",
        example=3000,
    )


class MeasurementDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth_range: Optional[DepthRange] = Field(None, alias="measuredDepthRange")


class MeasurementDataRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[MeasurementDataRequest]


class Metadata(WellsBaseModel):
    class Config:
        extra = Extra.allow

    __root__: str


class Survey(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="unique id for sequence in cdf")
    name: Optional[str] = Field(None, description="name of sequence Survey in cdf")
    description: Optional[str] = Field(None, description="additional description for the data")
    metadata: Optional[Dict[str, Metadata]] = Field(None, description="metadata connected to the sequence")


class SurveyRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row")
    values: List = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
    )


class ValueType(Enum):
    string = "STRING"
    double = "DOUBLE"
    long = "LONG"


class SurveyColumnInfo(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    value_type: Optional[ValueType] = Field(
        None,
        alias="valueType",
        description="What type the datapoints in a column will have. DOUBLE is restricted to the range [-1E100, 1E100]",
        example="DOUBLE",
    )


class SurveyDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="A server-generated ID for the object.")
    start: Optional[int] = Field(None, description="Lowest row number included.")
    end: Optional[int] = Field(None, description="Get rows up to, but excluding, this row number. Default - No limit")
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )
    columns: Optional[List[str]] = Field(
        None,
        description="Columns to be included. Specified as list of column external ids. In case this filter is not set, all available columns will be returned.",
    )


class SurveyData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int = Field(..., description="A server-generated ID for the object.")
    external_id: Optional[str] = Field(
        None, alias="externalId", description="A user provided identifier (Unique for a given survey)"
    )
    columns: List[SurveyColumnInfo] = Field(..., description="Column information in order given by data")
    rows: List[SurveyRow] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class SequenceValueTypeEnum(Enum):
    string = "string"
    double = "double"
    long = "long"


class SequenceRowDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row", example=1, ge=0.0)
    values: List = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
        max_items=200,
        min_items=1,
    )


class BasicGetSequenceColumnInfo(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    value_type: Optional[SequenceValueTypeEnum] = Field(None, alias="valueType")


class SequenceDataRequestDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[int] = None
    start: Optional[int] = Field(0, description="Lowest row number included.")
    end: Optional[int] = Field(
        None, description="Get rows up to, but excluding, this row number. Default - No limit", example=1
    )
    limit: Optional[int] = Field(
        100,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        example=1,
        ge=1.0,
        le=10000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )
    columns: Optional[List[str]] = Field(
        None,
        description="Columns to be included. Specified as list of column external ids. In case this filter is not set, all available columns will be returned.",
        max_items=200,
        min_items=1,
    )


class AssetSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    asset_external_id: str = Field(..., alias="assetExternalId")
    source_name: str = Field(..., alias="sourceName", example="EDM")


class EventSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    event_external_id: str = Field(..., alias="eventExternalId")
    source_name: str = Field(..., alias="sourceName")


class SequenceSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    source_name: str = Field(..., alias="sourceName", example="EDM")


class Error(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    code: int
    message: str


class ErrorResponse(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    error: Error


class Asset(WellsBaseModel):
    pass

    class Config:
        allow_population_by_field_name = True


class Source(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., example="EDM")
    description: Optional[str] = None


class Datum(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    elevation: DoubleWithUnit
    reference: str = Field(..., example="KB")


class LengthRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: float
    max: float
    unit: DistanceUnitEnum


class WellIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    name: str
    description: Optional[str] = Field(
        None, description="additional description for the data", example="extracted from EDM"
    )
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    spud_date: Optional[date] = Field(None, alias="spudDate")
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = Field(None, example="Example")
    operator: Optional[str] = Field(None, example="Op1")
    well_type: Optional[str] = Field(None, alias="wellType", description='For example "exploration" or "development"')
    license: Optional[str] = Field(None, description="Well license")
    water_depth: Optional[DoubleWithUnit] = Field(None, alias="waterDepth")
    wellhead: Optional[Wellhead] = None
    source: AssetSource


class DeleteWells(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[AssetSource]


class FieldSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    country: Optional[AssetSource] = None
    quadrant: Optional[AssetSource] = None
    spud_date: Optional[AssetSource] = Field(None, alias="spudDate")
    block: Optional[AssetSource] = None
    field: Optional[AssetSource] = None
    operator: Optional[AssetSource] = None
    well_type: Optional[AssetSource] = Field(None, alias="wellType")
    license: Optional[AssetSource] = None
    water_depth: Optional[AssetSource] = Field(None, alias="waterDepth")
    wellhead: Optional[AssetSource] = None


class IncompleteWell(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWell]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class Wellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    name: str
    description: Optional[str] = None
    well_matching_id: str = Field(..., alias="wellMatchingId")
    parent_wellbore_matching_id: Optional[str] = Field(
        None, alias="parentWellboreMatchingId", description="Parent wellbore if it exists"
    )
    sources: List[AssetSource]
    datum: Optional[Datum] = None


class WellboreIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId")
    name: str
    description: Optional[str] = None
    well_asset_external_id: str = Field(
        ..., alias="wellAssetExternalId", description="The CDF assetExternalId of the well parent of this wellbore"
    )
    parent_wellbore_asset_external_id: Optional[str] = Field(
        None,
        alias="parentWellboreAssetExternalId",
        description="If this wellbore is below another wellbore, add the parent wellbore's CDF assetExternalId here",
    )
    source: AssetSource
    datum: Optional[Datum] = None


class WellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Wellbore]


class FieldSources1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    datum: Optional[AssetSource] = None


class WellboreMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore: Wellbore
    field_sources: FieldSources1 = Field(..., alias="fieldSources")


class WellboreMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreMergeDetails]


class IncompleteWellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWellbore]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class NPT(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="ijiefe3:3463:npt"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="A written explanation of an NPT event.", example="leak:242"
    )
    npt_level: Optional[str] = Field(
        None, alias="nptLevel", description="defines the level of non-productive time for the activity.", example="0"
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="factual description of event"
    )
    start_time: int = Field(
        ...,
        alias="startTime",
        description="epoch time stamp in milliseconds for when the NPT event started.",
        example=1,
    )
    end_time: int = Field(
        ..., alias="endTime", description="epoch time stamp in milliseconds for when the NPT event ended.", example=1
    )
    measured_depth: Optional[DoubleWithUnit] = Field(None, alias="measuredDepth")
    duration: float = Field(..., description="Duration (hours) of the NPT event..", example=6.5)
    root_cause: Optional[str] = Field(
        None,
        alias="rootCause",
        description="Textual description of what caused the NPT event.",
        example="Leakage in pipe",
    )
    location: Optional[str] = Field(
        None, description="Location of NPT event.", example="location where failure event took place"
    )
    subtype: Optional[str] = Field(None, description="subtype of NPT event.", example="some subtype")


class NPTIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="ijiefe3:3463:npt"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="A written explanation of an NPT event.", example="leak:242"
    )
    npt_level: Optional[str] = Field(
        None, alias="nptLevel", description="defines the level of non-productive time for the activity.", example="0"
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="factual description of event"
    )
    start_time: int = Field(
        ..., alias="startTime", description="epoch time stamp in milliseconds for when the NPT event started."
    )
    end_time: int = Field(
        ..., alias="endTime", description="epoch time stamp in milliseconds for when the NPT event ended."
    )
    measured_depth: Optional[DoubleWithUnit] = Field(None, alias="measuredDepth")
    root_cause: Optional[str] = Field(
        None,
        alias="rootCause",
        description="Textual description of what caused the NPT event.",
        example="Leakage in pipe",
    )
    location: Optional[str] = Field(
        None, description="Location of NPT event.", example="location where failure event took place"
    )
    subtype: Optional[str] = Field(None, description="subtype of NPT event.")


class NPTIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NPTIngestion]


class NPTItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NPT]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class Filter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: Optional[LengthRange] = Field(None, alias="measuredDepth")
    duration: Optional[DoubleRange] = None
    npt_codes: Optional[List[str]] = Field(None, alias="nptCodes", description="match on any of the strings")
    npt_code_details: Optional[List[str]] = Field(
        None, alias="nptCodeDetails", description="match on any of the strings"
    )
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class NPTFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[Filter] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class WellNPTFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: Optional[LengthRange] = Field(None, alias="measuredDepth")
    duration: Optional[DoubleRange] = None
    npt_codes: Optional[ContainsAllOrAny] = Field(None, alias="nptCodes")
    npt_code_details: Optional[ContainsAllOrAny] = Field(None, alias="nptCodeDetails")


class NDS(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    source: EventSource = Field(..., description="The source of this event.")
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[DoubleWithUnit] = Field(None, alias="holeDiameter")
    hole_start: DoubleWithUnit = Field(..., alias="holeStart")
    hole_end: DoubleWithUnit = Field(..., alias="holeEnd")
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="subtype of NDS risk.", example="some subtype")
    severity: int = Field(..., description="severity of NDS event", example=1)
    probability: int = Field(..., description="NDS event probability, between 0-5")


class NDSItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NDS]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class NDSIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NDS event.\n",
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[DoubleWithUnit] = Field(None, alias="holeDiameter")
    hole_start: DoubleWithUnit = Field(..., alias="holeStart")
    hole_end: DoubleWithUnit = Field(..., alias="holeEnd")
    severity: int = Field(..., description="severity of NDS event", example=1)
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="subtype of NDS risk.", example="some subtype")
    probability: int = Field(..., description="NDS event probability, between 0-5")


class NDSIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NDSIngestion]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class Filter1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    hole_start: Optional[LengthRange] = Field(None, alias="holeStart")
    hole_end: Optional[LengthRange] = Field(None, alias="holeEnd")
    probabilities: Optional[List[int]] = None
    severities: Optional[List[int]] = None
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds")


class NDSFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[Filter1] = None
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class WellNDSFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    severities: Optional[ContainsAllOrAnyInt] = None
    probabilities: Optional[ContainsAllOrAnyInt] = None
    risk_types: Optional[ContainsAllOrAny] = Field(None, alias="riskTypes")


class SequenceMeasurementColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: MeasurementType = Field(..., alias="measurementType")
    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External id of the sequence column", example="GAMMA_RAY"
    )
    unit: str = Field(..., description="Unit for the measurement type", example="Roentgen")


class SequenceMeasurementColumnWithRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: MeasurementType = Field(..., alias="measurementType")
    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External id of the sequence column", example="GAMMA_RAY"
    )
    unit: str = Field(..., description="Unit for the measurement type", example="Roentgen")
    measured_depth_range: LengthRange = Field(..., alias="measuredDepthRange")


class Trajectory(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ..., alias="wellboreAssetExternalId", description="The CDF asset external id to the connected wellbore."
    )
    type: Optional[str] = None
    source: SequenceSource
    is_definitive: bool = Field(..., alias="isDefinitive")


class TrajectoryItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Trajectory]


class TrajectoryIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore where the event happened.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    is_definitive: bool = Field(..., alias="isDefinitive")
    rows: List[TrajectoryIngestionRow]


class TrajectoryData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    rows: List[TrajectoryDataRow]


class TrajectoryDataItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryData]


class CasingSchematic(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source: SequenceSource
    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    phase: str


class CasingIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    casing_assemblies: List[CasingAssembly] = Field(..., alias="casingAssemblies")
    source: SequenceSource
    phase: str


class TrajectoryFilterList(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[TrajectoryFilter] = None


class MeasurementFilters(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[MeasurementFilter]] = Field(
        None, alias="containsAll", description="match on all of the measurements"
    )
    contains_any: Optional[List[MeasurementFilter]] = Field(
        None, alias="containsAny", description="match on any of the measurements"
    )


class GetSequenceColumnDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(None, description="Human readable name of the column", example="depth")
    external_id: Optional[str] = Field(
        None,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    description: Optional[str] = Field(None, description="Description of the column", example="Optional description")
    value_type: SequenceValueTypeEnum = Field(..., alias="valueType")
    metadata: Optional[Dict[str, Metadata]] = Field(
        None,
        description="Custom, application specific metadata. String key -> String value",
        example={"extracted-by": "cognite"},
    )
    created_time: int = Field(
        ...,
        alias="createdTime",
        description="Time when this asset was created in CDF in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    last_updated_time: int = Field(
        ...,
        alias="lastUpdatedTime",
        description="The last time this asset was updated in CDF, in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )


class SequenceGetData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    external_id: str = Field(..., alias="externalId")
    columns: List[BasicGetSequenceColumnInfo] = Field(..., description="Column information in order given by data")
    rows: List[SequenceRowDTO] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class SequenceDataItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SequenceGetData]


class SourceItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Source]


class Well(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    name: str = Field(..., example="25/5-5")
    description: Optional[str] = Field(None, description="additional description for the data")
    country: Optional[str] = Field(None, example="Norway")
    quadrant: Optional[str] = Field(None, example="25")
    block: Optional[str] = Field(None, example="25/5")
    field: Optional[str] = None
    operator: Optional[str] = None
    spud_date: Optional[date] = Field(None, alias="spudDate")
    well_type: Optional[str] = Field(None, alias="wellType", description='For example "exploration" or "development"')
    license: Optional[str] = Field(None, description="Well license")
    wellhead: Wellhead
    water_depth: DoubleWithUnit = Field(..., alias="waterDepth")
    sources: List[AssetSource] = Field(
        ...,
        description="List of source systems that are associated to this well (user may drill down further to explore metadata for each source by calling well/{id}/source/{sourcename}",
    )
    wellbores: Optional[List[Wellbore]] = Field(None, description="List of wellbores associated to this well")


class WellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Well]
    next_cursor: Optional[str] = Field(None, alias="nextCursor")


class WellIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellIngestion]


class WellMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well: Well
    field_sources: FieldSources = Field(..., alias="fieldSources")


class WellMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellMergeDetails]


class WellboreIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreIngestion]


class SequenceMeasurements(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external id of the wellbore.\nThe asset must have been ingested as a wellbore with the same source\nas this NPT event.\n",
    )
    source: SequenceSource
    measured_depth: ColumnAndUnit = Field(..., alias="measuredDepth")
    columns: List[SequenceMeasurementColumn]


class MeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SequenceMeasurements]


class TrajectoryIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryIngestion]


class CasingIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[CasingIngestion]


class Filter2(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    quadrants: Optional[List[str]] = Field(None, example=["24", "25", "34"])
    blocks: Optional[List[str]] = Field(None, example=["24/6", "25/7", "34/1"])
    fields: Optional[List[str]] = Field(None, example=["Gullfaks", "Alvheim"])
    operators: Optional[List[str]] = Field(None, example=["op1", "op2"])
    well_types: Optional[List[str]] = Field(None, alias="wellTypes", example=["exploration", "development"])
    licenses: Optional[List[str]] = None
    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])
    water_depth: Optional[LengthRange] = Field(None, alias="waterDepth")
    spud_date: Optional[DateRange] = Field(None, alias="spudDate")
    trajectories: Optional[TrajectoryFilter] = None
    measurements: Optional[MeasurementFilters] = None
    polygon: Optional[PolygonFilter] = None
    npt: Optional[WellNPTFilter] = None
    nds: Optional[WellNDSFilter] = None


class WellFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[Filter2] = None
    search: Optional[Search] = None
    output_crs: Optional[str] = Field(None, alias="outputCrs", example="EPSG:4326")
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1.0,
        le=1000.0,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class GetSequenceDTO(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    name: Optional[str] = Field(None, description="Name of the sequence", example="Any relevant name")
    description: Optional[str] = Field(None, description="Description of the sequence", example="Optional description")
    asset_id: Optional[int] = Field(
        None, alias="assetId", description="Optional asset this sequence is associated with", example=1221123111
    )
    external_id: Optional[str] = Field(None, alias="externalId")
    metadata: Optional[Dict[str, Metadata]] = Field(
        None,
        description="Custom, application specific metadata. String key -> String value. Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
        example={"extracted-by": "cognite"},
    )
    columns: List[GetSequenceColumnDTO] = Field(..., description="List of column definitions")
    created_time: int = Field(
        ...,
        alias="createdTime",
        description="Time when this sequence was created in CDF in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    last_updated_time: int = Field(
        ...,
        alias="lastUpdatedTime",
        description="The last time this sequence was updated in CDF, in milliseconds since Jan 1, 1970.",
        example=100000000000,
    )
    data_set_id: Optional[int] = Field(
        None, alias="dataSetId", description="Data set that this sequence belongs to", example=2718281828459
    )


class MeasurementIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SequenceMeasurements]
