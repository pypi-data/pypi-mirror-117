[tool.poetry]
name = "groclimateclient"
# Note: we use poetry-dynamic-versioning to set the version from git tags.
version = "0.0.0.dev10"
description = "Python client library for accessing Gro Intelligence's climate data"
authors = ["Gro Intelligence developers <dev@gro-intelligence.com>"]
readme = "README.md"
homepage = "https://www.gro-intelligence.com"
repository = ""
documentation = ""
license = "MIT"

[tool.poetry.dependencies]
python = "^3.6.1"
numpy = "*"
requests = "*"
pandas = "*"
tornado = "*"
# unicodecsv = "*"

[tool.poetry.dev-dependencies]
# mock = "*"
# pytest = "*"
# pytest-cov = "*"

# [tool.poetry.extras]
# docs = ["sphinx", "recommonmark", "sphinx_rtd_theme", "sphinx-multiversion"]

[build-system]
requires = ["poetry-core>=1.0.0", "poetry-dynamic-versioning"]
build-backend = "poetry.core.masonry.api"

[tool.poetry-dynamic-versioning]
enable = false
vcs = "git"
style = "pep440"
# When packaging a version-tagged commit, the version is just the tag name
# (e.g. "1.84.0"). When the commit isn't version-tagged, we include a ".devN"
# suffix denoting how far from the last tagged version the commit is.
#
# Note that the .devN suffixes are ambiguous (with different branches, there
# can be different commits that result in the same .devN suffix). We use this
# scheme because PyPI requires it. We avoid ambiguity by:
# - PyPI: only uploading release packages
# - TestPyPI: only uploading packages when commits are merged to development
format-jinja = "{% if distance == 0 %}{{ base }}{% else %}{{ base }}.dev{{ distance }}{% endif %}"
